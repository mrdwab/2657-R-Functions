% 2657 Functions
% Ananda Mahto

concat.split
============

What It Does
------------

The `concat.split` function takes a column with multiple values, splits the values into separate columns, and returns a new `data.frame`.

Arguments
---------

* `data`: is the source `data.frame`
* `split.col`: the variable that needs to be split
* `mode`: can be either `binary` or `value` (where `binary` is default and it recodes values to `1` or `NA`)
* `sep`: the character separating each value (defaults to `","`) 
* `drop.col`: logical (whether to remove the original variable from the output or not; defaults to `TRUE`).

The Function
------------

```{r concat_split_function}
concat.split = function(data, split.col, mode=NULL, 
                        sep=",", drop.col=FALSE) {

  if (is.numeric(split.col)) split.col = split.col
  else split.col = which(colnames(data) %in% split.col)
  
  a = as.character(data[ , split.col])
  b = strsplit(a, sep)
  
  if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
    what = "string"
    ncol = max(unlist(lapply(b, function(i) length(i))))
  } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
    what = "numeric"
    ncol = max(as.numeric(unlist(b)))
  }
  
  m = matrix(nrow = nrow(data), ncol = ncol)
  v = vector("list", nrow(data))
  
  if (identical(what, "string")) {
    temp = as.data.frame(t(sapply(b, '[', 1:ncol)))
    names(temp) = paste(names(data[split.col]), "_", 1:ncol, sep="")
    temp1 = cbind(data, temp)
  } else if (identical(what, "numeric")) {
    for (i in 1:nrow(data)) {
      v[[i]] = as.numeric(strsplit(a, sep)[[i]])
    }
    
    temp = v
    
    for (i in 1:nrow(data)) {
      m[i, temp[[i]]] = temp[[i]]
    }
    
    m = data.frame(m)
    names(m) = paste(names(data[split.col]), "_", 1:ncol, sep="")
    
    if (is.null(mode) || identical(mode, "binary")) {
      temp1 = cbind(data, replace(m, m != "NA", 1))
    } else if (identical(mode, "value")) {
      temp1 = cbind(data, m)
    }
  } 
  
  if (isTRUE(drop.col)) temp1[-split.col]
  else temp1
  
}

```

Examples
--------

First load some data from a CSV stored at [github](http://github.com). The URL is an HTTPS, so we need to use `getURL` from `RCurl`.

```{r concat_split_data_loading}
require(RCurl)
baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
temp = getURL(paste0(baseURL, "data/concatenated-cells.csv"))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
# Just show me the first few rows
head(concat.test)
```

Notice that the data have been entered in a very silly manner. Let's split it up!

```{r concat_split_examples}
# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
# ... or by name, and drop the offensive first column
head(concat.split(concat.test, "Likes", drop.col=TRUE))
# Retain the original values
head(concat.split(concat.test, 2, mode="value", drop.col=TRUE))
# Let's try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col=TRUE))
```

To Do
-----

* Modify the function so that you can split multiple columns in one go?
* Strip whitespace from string output.

References
----------

See: [http://stackoverflow.com/q/10100887/1270695](http://stackoverflow.com/q/10100887/1270695)



row.extractor
=============

What It Does
------------

The `row.extractor` function takes a `data.frame` and extracts rows with the `min`, `median`, or `max` values of a given variable, or extracts rows with specific quantiles of a given variable.

Arguments
---------

* `data`: the source `data.frame`
* `extract.by`: the column which will be used as the reference for extraction
* `what`: options are `min` (for all rows matching the minimum value), `median` (for the median row or rows), `max` (for all rows matching the maximum value), or `all` (for `min`, `median`, and `max`); alternatively, a numeric vector can be specified with the desired quantiles, for instance `c(0, .25, .5, .75, 1)`

The Function
------------

```{r row_extractor_function}
row.extractor = function(data, extract.by, what="all") {
  
  if (is.numeric(extract.by)) {
    extract.by = extract.by
  } else if (is.numeric(extract.by) != 0) {
    extract.by = which(colnames(data) %in% "extract.by")
  } 
  
  if (is.character(what)) {
    which.median = function(data, extract.by) {
      a = data[, extract.by]
      if (length(a) %% 2 != 0) {
        which(a == median(a))
      } else if (length(a) %% 2 == 0) {
        b = sort(a)[c(length(a)/2, length(a)/2+1)]
        c(max(which(a == b[1])), min(which(a == b[2])))
      }
    }
    
    X1 = data[which(data[extract.by] == min(data[extract.by])), ] # min
    X2 = data[which(data[extract.by] == max(data[extract.by])), ] # max
    X3 = data[which.median(data, extract.by), ]                # median
    
    if (identical(what, "min")) {
      X1
    } else if (identical(what, "max")) {
      X2
    } else if (identical(what, "median")) {
      X3
    } else if (identical(what, "all")) {
      rbind(X1, X3, X2)
    }
  } else if (is.numeric(what)) {
    which.quantile <- function (data, extract.by, what, na.rm = FALSE) {
      
      x = data[ , extract.by]
      
      if (! na.rm & any (is.na (x)))
        return (rep (NA_integer_, length (what)))
      
      o <- order (x)
      n <- sum (! is.na (x))
      o <- o [seq_len (n)]
      
      nppm <- n * what - 0.5
      j <- floor(nppm)
      h <- ifelse((nppm == j) & ((j%%2L) == 0L), 0, 1)
      j <- j + h
      
      j [j == 0] <- 1
      o[j]
    }
    data[which.quantile(data, extract.by, what), ]           # quantile
  }
}
```

Examples
--------

```{r row_extractor_examples}
# Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), V3 = round(abs(rnorm(50)), digits=2), V4 = sample(1:30, 50, replace=TRUE))
# Get a sumary of the data
summary(dat)
# Get the rows corresponding to the 'min', 'median', and 'max' of 'V4'
row.extractor(dat, 4) 
# Get the 'min' rows only, referenced by the variable name
row.extractor(dat, "V4", "min") 
# Get the 'median' rows only. Notice that there are two rows since we have an even number of cases and true median is the mean of the two central sorted values
row.extractor(dat, "V4", "median") 
# Get the rows corresponding to the deciles of 'V3'
row.extractor(dat, "V3", seq(0.1, 1, 0.1)) 
```

To Do
-----

* None

References
----------

`which.quantile` function by [cbeleites](http://stackoverflow.com/users/755257/cbeleites)  
See: [http://stackoverflow.com/q/10256503/1270695](http://stackoverflow.com/q/10256503/1270695)