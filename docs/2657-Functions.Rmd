% 2657 Functions
% Ananda Mahto

\newpage
\tableofcontents
\newpage

concat.split
============

What it Does
------------

The `concat.split` function takes a column with multiple values, splits the values into separate columns, and returns a new `data.frame`.

Arguments
---------

* `data`: the source `data.frame`.
* `split.col`: the variable that needs to be split; can be specified either by the column number or the variable name.
* `mode`: can be either `binary` or `value` (where `binary` is default and it recodes values to `1` or `NA`).
* `sep`: the character separating each value (defaults to `","`).
* `drop.col`: logical (whether to remove the original variable from the output or not; defaults to `TRUE`).

Examples
--------

First load some data from a CSV stored at [github](http://github.com). The URL is an HTTPS, so we need to use `getURL` from `RCurl`.

```{r concat_split_data_loading}
require(RCurl)
baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
temp = getURL(paste0(baseURL, "data/concatenated-cells.csv"))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
# Just show me the first few rows
head(concat.test)
```

Notice that the data have been entered in a very silly manner. Let's split it up!

```{r concat_split_examples}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/concat.split.R"))))

# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
# ... or by name, and drop the offensive first column
head(concat.split(concat.test, "Likes", drop.col=TRUE))
# The "Hates" column uses a different separator:
head(concat.split(concat.test, "Hates", sep=";", drop.col=TRUE))
# Retain the original values
head(concat.split(concat.test, 2, mode="value", drop.col=TRUE))
# Let's try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col=TRUE))
```

To Do
-----

* Add the option to put the output as `list`s instead of adding multiple columns to the `data.frame`.
* Modify the function so that you can split multiple columns in one go?

References
----------

See: [http://stackoverflow.com/q/10100887/1270695](http://stackoverflow.com/q/10100887/1270695)



\newpage

df.sorter
=========

What it Does
------------

The `df.sorter` function allows you to sort a `data.frame` by columns or rows or both. You can also quickly subset data solums by using the `var.order` argument.

Arguments
---------

* `data`: the source `data.frame`.
* `var.order`: the new order in which you want the variables to appear.
    * Defaults to `names(data)`, which keeps the variables in the original order.
    * Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).
    * Basic subsetting can also be done using `var.order` simply by omitting the variables you want to drop.
* `col.sort`: the columns *within* which there is data that need to be sorted.
    * Defaults to `NULL`, which means no sorting takes place.
    * Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.
* `at.start`: Should the pattern matching be from the start of the variable name? Defaults to "TRUE".

> NOTE: If you are sorting both by variables and within the columns, the `col.sort` order should be based on the location of the columns in the *new* `data.frame`, not the original `data.frame`.

Examples
--------

```{r df_sorter_examples}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/df.sorter.R"))))

# Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each=3), times = rep(1:3, 5),
                 measure1 = rnorm(15), score1 = sample(300, 15),
                 code1 = replicate(15, paste(sample(LETTERS[1:5], 3), sep="", collapse="")),
                 measure2 = rnorm(15), score2 = sample(150:300, 15), 
                 code2 = replicate(15, paste(sample(LETTERS[1:5], 3), sep="", collapse="")))
# Preview your data
dat
# Change the variable order, grouping related columns
# Note that you do not need to specify full variable names,
#    just enough that the variables can be uniquely identified
head(df.sorter(dat, var.order = c("id", "ti", "cod", "mea", "sco")))
# Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
# As above, but sorted by 'times' and then 'id'
head(df.sorter(dat, var.order = c("id", "tim", "cod", "mea", "sco"), col.sort = c(2, 1)))
# Drop 'measure1' and 'measure2', sort by 'times', and 'score1'
head(df.sorter(dat, var.order = c("id", "tim", "sco", "cod"), col.sort = c(2, 3)))
# As above, but using names
head(df.sorter(dat, var.order = c("id", "tim", "sco", "cod"), col.sort = c("times", "score1")))
# Just sort by columns, first by 'times' then by 'id'
head(df.sorter(dat, col.sort = c("times", "id")))
head(df.sorter(dat, col.sort = c("code1"))) # Sorting by character values
# Pattern matching anywhere in the variable name
head(df.sorter(dat, var.order= "co", at.start=FALSE))
```

To Do
-----

* Add an option to sort ascending or descending---at the moment, not supported.



\newpage

multi.freq.table
================

What it Does
------------
The `multi.freq.table` function takes a data frame containing boolean responses to multiple response questions and tabulates the number of responses by the possible combinations of answers.

Arguments
---------
* `data`: The multiple responses that need to be tabulated.
* `sep`: The desired separator for collapsing the combinations of options; defaults to `""` (collapsing with no space between each option name).
* `dropzero`: Should combinations with a frequency of zero be dropped from the final table? Defaults to `FALSE`.
* `clean`: Should the original tabulated data be retained or dropped from the final table? Defaults to `TRUE`.

Examples
--------
```{r multi_freq_table_examples}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/multi.freq.table.R"))))

# Make up some data
set.seed(1)
dat = data.frame(A = sample(c(0, 1), 20, replace=TRUE),
                 B = sample(c(0, 1), 20, replace=TRUE),
                 C = sample(c(0, 1), 20, replace=TRUE),
                 D = sample(c(0, 1), 20, replace=TRUE),
                 E = sample(c(0, 1), 20, replace=TRUE))
# View your data
dat
# Apply the function with all defaults accepted
multi.freq.table(dat)
# Tabulate only on variables "A", "B", and "D", with a different
# separator, dropping any zero frequency values, and keeping the original tabulations.
# Note that there are no solitary "B" responses.
multi.freq.table(dat[c(1, 2, 4)], sep="-", dropzero=TRUE, clean=FALSE)
```


References
----------
`apply` shortcut for creating the `Combn` column in the output by [Justin](http://stackoverflow.com/users/906490/justin)  
See: [http://stackoverflow.com/q/11348391/1270695](http://stackoverflow.com/q/11348391/1270695)

\newpage

row.extractor
=============

What it Does
------------

The `row.extractor` function takes a `data.frame` and extracts rows with the `min`, `median`, or `max` values of a given variable, or extracts rows with specific quantiles of a given variable.

Arguments
---------

* `data`: the source `data.frame`.
* `extract.by`: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.
* `what`: options are `min` (for all rows matching the minimum value), `median` (for the median row or rows), `max` (for all rows matching the maximum value), or `all` (for `min`, `median`, and `max`); alternatively, a numeric vector can be specified with the desired quantiles, for instance `c(0, .25, .5, .75, 1)`

Examples
--------

```{r row_extractor_examples}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/row.extractor.R"))))

# Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), V3 = round(abs(rnorm(50)), digits=2), V4 = sample(1:30, 50, replace=TRUE))
# Get a sumary of the data
summary(dat)
# Get the rows corresponding to the 'min', 'median', and 'max' of 'V4'
row.extractor(dat, 4) 
# Get the 'min' rows only, referenced by the variable name
row.extractor(dat, "V4", "min") 
# Get the 'median' rows only. Notice that there are two rows since we have an even number of cases and true median is the mean of the two central sorted values
row.extractor(dat, "V4", "median") 
# Get the rows corresponding to the deciles of 'V3'
row.extractor(dat, "V3", seq(0.1, 1, 0.1)) 
```


References
----------

`which.quantile` function by [cbeleites](http://stackoverflow.com/users/755257/cbeleites)  
See: [http://stackoverflow.com/q/10256503/1270695](http://stackoverflow.com/q/10256503/1270695)

\newpage

\appendix

The Functions
=============

The most current source code for the functions described in this document follow.

To load the functions, you can directly source them from the 2657 R Functions page at github: [https://github.com/mrdwab/2657-R-Functions](https://github.com/mrdwab/2657-R-Functions)

You should be able to load the functions using the following (replace `-----------` with the function name):

```{r eval=FALSE}
require(RCurl)
baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/-----------.R"))))
```

\newpage

concat.split
------------

```{r echo=FALSE, eval=TRUE, comment=NA}
writeLines(readLines("~/2657-R-Functions/scripts/concat.split.R"))
```

\newpage

df.sorter
---------

```{r echo=FALSE, eval=TRUE, comment=NA}
writeLines(readLines("~/2657-R-Functions/scripts/df.sorter.R"))
```

\newpage

multi.freq.table
----------------

```{r echo=FALSE, eval=TRUE, comment=NA}
writeLines(readLines("~/2657-R-Functions/scripts/multi.freq.table.R"))
```

\newpage

row.extractor
---------------

```{r echo=FALSE, eval=TRUE, comment=NA}
writeLines(readLines("~/2657-R-Functions/scripts/row.extractor.R"))
```