% 2657 Functions
% Ananda Mahto

\pagenumbering{gobble}

```{r set-options, echo=FALSE, cache=FALSE}
options(width=80)
read_chunk("../scripts/concat.split.R")
read_chunk("../scripts/df.sorter.R")
read_chunk("../scripts/multi.freq.table.R")
read_chunk("../scripts/row.extractor.R")
read_chunk("../scripts/snippets.R")
```

\pagestyle{plain}
\tableofcontents
\cleardoublepage

\pagestyle{headings}
\setcounter{page}{1}
\pagenumbering{arabic}

\part{Function Descriptions and Examples}

# concat.split

## What it Does

The `concat.split` function takes a column with multiple values, splits the values into a list or into separate columns, and returns a new `data.frame`.

## Arguments

* `data`: the source `data.frame`.
* `split.col`: the variable that needs to be split; can be specified either by the column number or the variable name.
* `to.list`: logical; should the split column be returned as a single variable list (named "original-variable_list") or multiple new variables? If `to.list` is `TRUE`, the `mode` argument is ignored and a list of the original values are returned.
* `mode`: can be either `binary` or `value` (where `binary` is default and it recodes values to `1` or `NA`, like Boolean, but without assuming `0` when data is not available).
* `sep`: the character separating each value (defaults to `","`).
* `drop.col`: logical (whether to remove the original variable from the output or not; defaults to `TRUE`).

## Examples

First load some data from a CSV stored at [github](http://github.com). The URL is an HTTPS, so we need to use `getURL` from `RCurl`.

```{r concat_split_data_loading, tidy=FALSE}
require(RCurl)
baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
temp = getURL(paste0(baseURL, "data/concatenated-cells.csv"))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
# Just show me the first few rows
head(concat.test)
```

Notice that the data have been entered in a very silly manner. Let's split it up!

```{r concat_split_examples, tidy=FALSE}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/concat.split.R"))))

# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
# ... or by name, and drop the offensive first column
head(concat.split(concat.test, "Likes", drop.col=TRUE))
# The "Hates" column uses a different separator:
head(concat.split(concat.test, "Hates", sep=";", drop.col=TRUE))
# Retain the original values
head(concat.split(concat.test, 2, mode="value", drop.col=TRUE))
# Let's try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col=TRUE))
# Split up the "Likes column" into a list variable; retain original column
head(concat.split(concat.test, 2, to.list=TRUE, drop.col=FALSE))
# View the structure of the output for the first 10 rows to verify 
# that the new column is a list; note the difference between "Likes"
# and "Likes_list".
str(concat.split(concat.test, 2, to.list=TRUE, drop.col=FALSE)[1:10, c(2, 5)])
```

## Advanced Usage

It is also possible to use `concat.split` to split multiple columns at once. This can be done in stages, or it can be all wrapped in nested statements, as follows:

```{r concat_split_advanced, eval=FALSE, tidy=FALSE}
do.call(cbind, c(concat.test[1],
                 lapply(lapply(2:ncol(concat.test),
                               function(x) concat.test[x]),
                        concat.split, split.col=1, drop=TRUE, sep=";|,")))
```

In the example above (working from the inside of the function outwards):

* First, `lapply(2:ncol(concat.test), ...)` splits the columns of the `data.frame` into a list. 
* Second, `lapply(lapply(...))` does the splitting work.
    * Note the use of `sep=";|,"` to match multiple separators on which to split; if further separators are required, they can be specified by using the pipe symbol (`|`) *with no leading or trailing spaces*.
* Finally, `do.call(cbind, ...)` is evaluated last, "binding" the data together by columns. In this case, the data being bound together is the first column from the `concat.test` dataset, and the splitted output of the remaining columns. 

Alternatively, a similar approach can be taken using the function `dfcols.list` (see the "Snippets and Tips" section of this manual for the `dfcols.list` function).

```{r dfcolslist, echo=FALSE, eval=TRUE}
```

```{r concat_split_advanced_2, tidy=FALSE}
# Show just the first few lines, Boolean mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, sep=";|,"))))
# Show just the first few lines, value mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, 
                             sep=";|,", mode="value"))))
# Show just the first few lines, list output mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, 
                             sep=";|,", to.list=TRUE))))
```

## References

See: [http://stackoverflow.com/q/10100887/1270695](http://stackoverflow.com/q/10100887/1270695)



\newpage


# df.sorter

## What it Does

The `df.sorter` function allows you to sort a `data.frame` by columns or rows or both. You can also quickly subset data columns by using the `var.order` argument.

## Arguments

* `data`: the source `data.frame`.
* `var.order`: the new order in which you want the variables to appear.
    * Defaults to `names(data)`, which keeps the variables in the original order.
    * Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).
    * Basic subsetting can also be done using `var.order` simply by omitting the variables you want to drop.
* `col.sort`: the columns *within* which there is data that need to be sorted.
    * Defaults to `NULL`, which means no sorting takes place.
    * Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.
* `at.start`: Should the pattern matching be from the start of the variable name? Defaults to "TRUE".

> NOTE: If you are sorting both by variables and within the columns, the `col.sort` order should be based on the location of the columns in the *new* `data.frame`, not the original `data.frame`.

## Examples

```{r df_sorter_examples, tidy=FALSE}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/df.sorter.R"))))

# Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each=3), times = rep(1:3, 5),
                 measure1 = rnorm(15), score1 = sample(300, 15),
                 code1 = replicate(15, paste(sample(LETTERS[1:5], 3), 
                                             sep="", collapse="")),
                 measure2 = rnorm(15), score2 = sample(150:300, 15), 
                 code2 = replicate(15, paste(sample(LETTERS[1:5], 3), 
                                             sep="", collapse="")))
# Preview your data
dat
# Change the variable order, grouping related columns
# Note that you do not need to specify full variable names,
#    just enough that the variables can be uniquely identified
head(df.sorter(dat, var.order = c("id", "ti", "cod", "mea", "sco")))
# Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
# As above, but sorted by 'times' and then 'id'
head(df.sorter(dat, var.order = c("id", "tim", "cod", "mea", "sco"), 
               col.sort = c(2, 1)))
# Drop 'measure1' and 'measure2', sort by 'times', and 'score1'
head(df.sorter(dat, var.order = c("id", "tim", "sco", "cod"), 
               col.sort = c(2, 3)))
# As above, but using names
head(df.sorter(dat, var.order = c("id", "tim", "sco", "cod"), 
               col.sort = c("times", "score1")))
# Just sort by columns, first by 'times' then by 'id'
head(df.sorter(dat, col.sort = c("times", "id")))
head(df.sorter(dat, col.sort = c("code1"))) # Sorting by character values
# Pattern matching anywhere in the variable name
head(df.sorter(dat, var.order= "co", at.start=FALSE))
```

## To Do

* Add an option to sort ascending or descending---at the moment, not supported.



\newpage


# multi.freq.table

## What it Does

The `multi.freq.table` function takes a data frame containing Boolean responses to multiple response questions and tabulates the number of responses by the possible combinations of answers. In addition to tabulating the frequency (`Freq`), there are two other columns in the output: *Percent of Responses* (`Pct.of.Resp`) and *Percent of Cases* (`Pct.of.Cases`). *Percent of Responses* is the frequency divided by the total number of answers provided; this column should sum to 100%. *Percent of Cases* is the frequency divided by the total number of valid cases; this column would mot likely sum to more than 100% since each respondent (case) can select multiple answers.

## Arguments

* `data`: The multiple responses that need to be tabulated.
* `sep`: The desired separator for collapsing the combinations of options; defaults to `""` (collapsing with no space between each option name).
* `dropzero`: Should combinations with a frequency of zero be dropped from the final table? Defaults to `FALSE`.
* `clean`: Should the original tabulated data be retained or dropped from the final table? Defaults to `TRUE`.
* `basic`: Should a basic table of each item, rather than combinations of items, be created? Defaults to `FALSE`.

## Examples

```{r multi_freq_table_examples, tidy=FALSE}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/multi.freq.table.R"))))

# Make up some data
set.seed(1)
dat = data.frame(A = sample(c(0, 1), 20, replace=TRUE),
                 B = sample(c(0, 1), 20, replace=TRUE),
                 C = sample(c(0, 1), 20, replace=TRUE),
                 D = sample(c(0, 1), 20, replace=TRUE),
                 E = sample(c(0, 1), 20, replace=TRUE))
# View your data
dat
# Apply the function with all defaults accepted
multi.freq.table(dat)
# Tabulate only on variables "A", "B", and "D", with a different
# separator, dropping any zero frequency values, and keeping the original tabulations.
# Note that there are no solitary "B" responses.
multi.freq.table(dat[c(1, 2, 4)], sep="-", dropzero=TRUE, clean=FALSE)
# View a basic table.
multi.freq.table(dat, basic=TRUE)
```

## To Do

* Update docs with `useNA`.
* Update function to deal with `NA` responses better.
* Update function for dealing with different types of multiple response questions input formats.

## References

`apply` shortcut for creating the `Combn` column in the output by [Justin](http://stackoverflow.com/users/906490/justin)  
See: [http://stackoverflow.com/q/11348391/1270695](http://stackoverflow.com/q/11348391/1270695) and [http://stackoverflow.com/q/11622660/1270695](http://stackoverflow.com/q/11622660/1270695)

\newpage


# row.extractor

## What it Does

The `row.extractor` function takes a `data.frame` and extracts rows with the `min`, `median`, or `max` values of a given variable, or extracts rows with specific quantiles of a given variable.

## Arguments

* `data`: the source `data.frame`.
* `extract.by`: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.
* `what`: options are `min` (for all rows matching the minimum value), `median` (for the median row or rows), `max` (for all rows matching the maximum value), or `all` (for `min`, `median`, and `max`); alternatively, a numeric vector can be specified with the desired quantiles, for instance `c(0, .25, .5, .75, 1)`

## Examples

```{r row_extractor_examples, tidy=FALSE}
# Load the function!
# require(RCurl)
# baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/row.extractor.R"))))

# Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), 
                 V3 = round(abs(rnorm(50)), digits=2), 
                 V4 = sample(1:30, 50, replace=TRUE))
# Get a sumary of the data
summary(dat)
# Get the rows corresponding to the 'min', 'median', and 'max' of 'V4'
row.extractor(dat, 4) 
# Get the 'min' rows only, referenced by the variable name
row.extractor(dat, "V4", "min") 
# Get the 'median' rows only. Notice that there are two rows 
#    since we have an even number of cases and true median 
#    is the mean of the two central sorted values
row.extractor(dat, "V4", "median") 
# Get the rows corresponding to the deciles of 'V3'
row.extractor(dat, "V3", seq(0.1, 1, 0.1)) 
```


## References

`which.quantile` function by [cbeleites](http://stackoverflow.com/users/755257/cbeleites)  
See: [http://stackoverflow.com/q/10256503/1270695](http://stackoverflow.com/q/10256503/1270695)

\newpage

\part{The Functions}

# Where to Get the Functions

The most current source code for the functions described in this document follow.

To load the functions, you can directly source them from the 2657 R Functions page at github: [https://github.com/mrdwab/2657-R-Functions](https://github.com/mrdwab/2657-R-Functions)

You should be able to load the functions using the following (replace `-----------` with the function name^[The "snippets" in Part III of this document can all be loaded from the script `snippets.R`.]):

```{r rcurl_load_scripts, eval=FALSE}
require(RCurl)
baseURL = c("https://raw.github.com/mrdwab/2657-R-Functions/master/")
source(textConnection(getURL(paste0(baseURL, "scripts/-----------.R"))))
```

\newpage

# concat.split

```{r concatsplit, tidy=FALSE}
```

\newpage

# df.sorter

```{r dfsorter, tidy=FALSE}
```

\newpage

# multi.freq.table

```{r multifreqtable, tidy=FALSE}
```

\newpage

# row.extractor

```{r rowextractor, tidy=FALSE}
```

\newpage

\part{Snippets and Tips}

# Snippets

## Load All Scripts and Data Files From Multiple Directories

```{r scriptsanddata, tidy=FALSE}
```

## Convert a List of Data Frames Into Individual Data Frames

```{r unlistdfs, tidy=FALSE}
```

### Example

*Note that the list name must be quoted.*

```{r unlistdfs_example, tidy=FALSE}
# Sample data
temp = list(A = data.frame(A = 1:2, B = 3:4), 
            B = data.frame(C = 5:6, D = 7:8))
temp
# Remove any files with similar names to output
rm(list=ls(pattern="temp_"))
# The following should not work
temp_1
# Split it up!
unlist.dfs("temp")
# List files with the desired pattern
ls(pattern="temp_")
# View the new files
temp_1
temp_2
```

## Convert a Data Frame Into a List With Each Column Becoming a List Item

```{r dfcolslist, tidy=FALSE}
```

### Examples

```{r dfcolslist_examples, tidy=FALSE}
# Sample data
dat = data.frame(A = c(1:2), B = c(3:4), C = c(5:6))
dat
# Split into a list, retaining data.frame structure
dfcols.list(dat)
# Split into a list, converting to vector
dfcols.list(dat, vectorize=TRUE)
```

## Rename an Object in the Workplace

```{r rmmove, tidy=FALSE}
```

### Basic Usage

If there is already an object with the same name in the workplace, the function will ask you if you want to replace the object or not. Otherwise, the basic usage is:

```{r rmmove_example, eval=FALSE, tidy=FALSE}
# Rename "object_1" to "object_2"
mv(object_1, object_2)
```



\newpage

# Tips

Many of the following tips are useful for reducing repetitious tasks. They might seem silly or unnecessary with the small examples provided, but they can be *huge* time-savers when dealing with larger objects or larger sets of data.

## Batch Convert Factor Variables to Character Variables

In the example data below, `author` and `title` are automatically converted to factor (unless you add the argument `stringsAsFactor = FALSE` when you are creating the data). What if you forgot and actually needed the variables to be in mode `as.character` instead?

Use `sapply` to identify which variables are currently factors and convert them to `as.character`.

```{r factortocharacter, tidy=FALSE}
dat = data.frame(title = c("title1", "title2", "title3"),
                 author = c("author1", "author2", "author3"),
                 customerID = c(1, 2, 1))
str(dat)
# Left of the equal sign identifies and extracts the factor variables;
#    right converts them from factor to character
dat[sapply(dat, is.factor)] = lapply(dat[sapply(dat, is.factor)], 
                                     as.character)
str(dat)
```

## Using Reduce to Merge Multiple Data Frames at Once

The `merge` function in R only merges two objects at a time. This is usually fine, but what if you had several `data.frames` that needed to be merged?

Consider the following data, where we want to take monthly tables and merge them into an annual table:

```{r reduce_sample_data, tidy=FALSE}
set.seed(1)
JAN = data.frame(ID = sample(5, 3), JAN = sample(LETTERS, 3))
FEB = data.frame(ID = sample(5, 3), FEB = sample(LETTERS, 3))
MAR = data.frame(ID = sample(5, 3), MAR = sample(LETTERS, 3))
APR = data.frame(ID = sample(5, 3), APR = sample(LETTERS, 3))
```

If we wanted to merge these into a single `data.frame` using `merge`, we might end up creating several temporary objects and merging those, like this:

```{r merge_nonsense_1, tidy=FALSE, eval=FALSE}
temp_1 = merge(JAN, FEB, all=TRUE)
temp_2 = merge(temp_1, MAR, all=TRUE)
temp_3 = merge(temp_2, APR, all=TRUE)
```

Or, we might nest a whole bunch of `merge` commands together, something like this:

```{r merge_nonsense, tidy=FALSE, eval=FALSE}
merge(merge(merge(JAN, FEB, all=TRUE), 
            MAR, all=TRUE), 
      APR, all=TRUE)
```

However, that first option requires a lot of unnecessary typing and produces unnecessary objects that we then need to remember to remove, and the second option is not very reader-friendly---try doing a merge like that with, say, 12 `data.frames` if we had an entire year of data!

Use `Reduce` instead, simply specifying all the objects to be merged in a `list`:

```{r merge_reduce, tidy=FALSE}
Reduce(function(x, y) merge(x, y, all=TRUE), 
       list(JAN, FEB, MAR, APR))
```

### How Much Memory Are the Objects in Your Workspace Using?

Sometimes you need to just check and see how much memory the objects in your workspace occupy.

```{r memoryoccupy, tidy=FALSE, eval=FALSE}
sort(sapply(ls(), function(x) {object.size(get(x))}))
```


