<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>concat.split</h1>

<h2>What it Does</h2>

<p>The <code>concat.split</code> function takes a column with multiple values, splits the values into separate columns, and returns a new <code>data.frame</code>.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>split.col</code>: the variable that needs to be split; can be specified either by the column number or the variable name.</li>
<li><code>mode</code>: can be either <code>binary</code> or <code>value</code> (where <code>binary</code> is default and it recodes values to <code>1</code> or <code>NA</code>).</li>
<li><code>sep</code>: the character separating each value (defaults to <code>&quot;,&quot;</code>).</li>
<li><code>drop.col</code>: logical (whether to remove the original variable from the output or not; defaults to <code>TRUE</code>).</li>
</ul>

<h2>Examples</h2>

<p>First load some data from a CSV stored at <a href="http://github.com">github</a>. The URL is an HTTPS, so we need to use <code>getURL</code> from <code>RCurl</code>.</p>

<pre><code class="r">require(RCurl)
</code></pre>

<pre><code class="no-highlight">## Loading required package: RCurl
</code></pre>

<pre><code class="no-highlight">## Loading required package: bitops
</code></pre>

<pre><code class="r">baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
temp = getURL(paste0(baseURL, &quot;data/concatenated-cells.csv&quot;))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
</code></pre>

<pre><code class="no-highlight">## [1] 48  4
</code></pre>

<pre><code class="r"># Just show me the first few rows
head(concat.test)
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings    Hates
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;
## 3   Dana 1,2,4,5,6                     Pierce       2;
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;
</code></pre>

<p>Notice that the data have been entered in a very silly manner. Let&#39;s split it up!</p>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/concat.split.R&quot;))))

# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings    Hates Likes_1 Likes_2
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;       1       1
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;       1       1
## 3   Dana 1,2,4,5,6                     Pierce       2;       1       1
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;       1       1
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;       1       1
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;       1       1
##   Likes_3 Likes_4 Likes_5 Likes_6
## 1      NA       1       1       1
## 2      NA       1       1       1
## 3      NA       1       1       1
## 4      NA       1       1       1
## 5      NA      NA       1       1
## 6      NA      NA       1       1
</code></pre>

<pre><code class="r"># ... or by name, and drop the offensive first column
head(concat.split(concat.test, &quot;Likes&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       1      NA
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       1      NA
## 3   Dana                     Pierce       2;       1       1      NA
## 4 Carole Colon , Michelle , Ballard     1;4;       1       1      NA
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       1      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       1      NA
##   Likes_4 Likes_5 Likes_6
## 1       1       1       1
## 2       1       1       1
## 3       1       1       1
## 4       1       1       1
## 5      NA       1       1
## 6      NA       1       1
</code></pre>

<pre><code class="r"># The &#39;Hates&#39; column uses a different separator:
head(concat.split(concat.test, &quot;Hates&quot;, sep = &quot;;&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings Hates_1 Hates_2 Hates_3
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega      NA       1      NA
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery       1       1       1
## 3   Dana 1,2,4,5,6                     Pierce      NA       1      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard       1      NA      NA
## 5 Ramona   1,2,5,6           Snyder , Joann ,       1       1       1
## 6 Kelley   1,2,5,6          James , Roxanne ,       1      NA      NA
##   Hates_4
## 1       1
## 2       1
## 3      NA
## 4       1
## 5      NA
## 6       1
</code></pre>

<pre><code class="r"># Retain the original values
head(concat.split(concat.test, 2, mode = &quot;value&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       2      NA
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       2      NA
## 3   Dana                     Pierce       2;       1       2      NA
## 4 Carole Colon , Michelle , Ballard     1;4;       1       2      NA
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       2      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       2      NA
##   Likes_4 Likes_5 Likes_6
## 1       4       5       6
## 2       4       5       6
## 3       4       5       6
## 4       4       5       6
## 5      NA       5       6
## 6      NA       5       6
</code></pre>

<pre><code class="r"># Let&#39;s try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes    Hates Siblings_1 Siblings_2 Siblings_3
## 1   Boyd 1,2,4,5,6     2;4;   Reynolds     Albert     Ortega
## 2  Rufus 1,2,4,5,6 1;2;3;4;      Cohen       Bert Montgomery
## 3   Dana 1,2,4,5,6       2;     Pierce       &lt;NA&gt;       &lt;NA&gt;
## 4 Carole 1,2,4,5,6     1;4;      Colon   Michelle    Ballard
## 5 Ramona   1,2,5,6   1;2;3;     Snyder      Joann       &lt;NA&gt;
## 6 Kelley   1,2,5,6     1;4;      James    Roxanne       &lt;NA&gt;
</code></pre>

<h2>To Do</h2>

<ul>
<li>Modify the function so that you can split multiple columns in one go?</li>
</ul>

<h2>References</h2>

<p>See: <a href="http://stackoverflow.com/q/10100887/1270695">http://stackoverflow.com/q/10100887/1270695</a></p>

<p>\newpage</p>

<h1>df.sorter</h1>

<h2>What it Does</h2>

<p>The <code>df.sorter</code> function allows you to sort a <code>data.frame</code> by columns or rows or both. You can also quickly subset data solums by using the <code>var.order</code> argument.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>var.order</code>: the new order in which you want the variables to appear.

<ul>
<li>Defaults to <code>names(data)</code>, which keeps the variables in the original order.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).</li>
<li>Basic subsetting can also be done using <code>var.order</code> simply by omitting the variables you want to drop.</li>
</ul></li>
<li><code>col.sort</code>: the columns <em>within</em> which there is data that need to be sorted.

<ul>
<li>Defaults to <code>NULL</code>, which means no sorting takes place.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.</li>
</ul></li>
<li><code>at.start</code>: Should the pattern matching be from the start of the variable name? Defaults to &ldquo;TRUE&rdquo;.</li>
</ul>

<blockquote>
<p>NOTE: If you are sorting both by variables and within the columns, the <code>col.sort</code> order should be based on the location of the columns in the <em>new</em> <code>data.frame</code>, not the original <code>data.frame</code>.</p>
</blockquote>

<h2>Examples</h2>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/df.sorter.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each = 3), times = rep(1:3, 5), measure1 = rnorm(15), 
    score1 = sample(300, 15), code1 = replicate(15, paste(sample(LETTERS[1:5], 
        3), sep = &quot;&quot;, collapse = &quot;&quot;)), measure2 = rnorm(15), score2 = sample(150:300, 
        15), code2 = replicate(15, paste(sample(LETTERS[1:5], 3), sep = &quot;&quot;, 
        collapse = &quot;&quot;)))
# Preview your data
dat
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
## 3   1     3  -0.8356    148   EBA   0.7685    222   DAE
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
## 6   2     3  -0.8205    198   EBD   0.3981    216   DCA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 9   3     3   0.5758    212   EBC  -1.1294    182   BEC
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 11  4     2   1.5118    239   EDB   1.9804    231   CAB
## 12  4     3   0.3898    188   DEB  -0.3672    160   DBE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 14  5     2  -2.2147    159   DAC   0.5697    238   BDE
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
</code></pre>

<pre><code class="r"># Change the variable order, grouping related columns Note that you do not
# need to specify full variable names, just enough that the variables can
# be uniquely identified
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;ti&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># As above, but sorted by &#39;times&#39; and then &#39;id&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;), 
    col.sort = c(2, 1)))
</code></pre>

<pre><code class="no-highlight">##    id times code1 code2 measure1 measure2 score1 score2
## 1   1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 4   2     1   AED   DBA   1.5953  -0.1123     56    175
## 7   3     1   BCA   CEA   0.4874  -0.6120    234    300
## 10  4     1   BED   CDE  -0.3054   1.4330    120    234
## 13  5     1   DBA   EDB  -0.6212  -1.0441    226    154
## 2   1     2   DCB   ECD   0.1836   0.3646    180    224
</code></pre>

<pre><code class="r"># Drop &#39;measure1&#39; and &#39;measure2&#39;, sort by &#39;times&#39;, and &#39;score1&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(2, 
    3)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># As above, but using names
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(&quot;times&quot;, 
    &quot;score1&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># Just sort by columns, first by &#39;times&#39; then by &#39;id&#39;
head(df.sorter(dat, col.sort = c(&quot;times&quot;, &quot;id&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
</code></pre>

<pre><code class="r">head(df.sorter(dat, col.sort = c(&quot;code1&quot;)))  # Sorting by character values
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
</code></pre>

<pre><code class="r"># Pattern matching anywhere in the variable name
head(df.sorter(dat, var.order = &quot;co&quot;, at.start = FALSE))
</code></pre>

<pre><code class="no-highlight">##   code1 code2 score1 score2
## 1   DAB   CEB    145    299
## 2   DCB   ECD    180    224
## 3   EBA   DAE    148    222
## 4   AED   DBA     56    175
## 5   CEB   DAC    245    260
## 6   EBD   DCA    198    216
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add an option to sort ascending or descending&mdash;at the moment, not supported.</li>
</ul>

<p>\newpage</p>

<h1>multi.freq.table</h1>

<h2>What it Does</h2>

<p>The <code>multi.freq.table</code> function takes a data frame containing boolean responses to multiple response questions and tabulates the number of responses by the possible combinations of answers.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: The multiple responses that need to be tabulated.</li>
<li><code>sep</code>: The desired separator for collapsing the combinations of options; defaults to <code>&quot;&quot;</code> (collapsing with no space between each option name).</li>
<li><code>dropzero</code>: Should combinations with a frequency of zero be dropped from the final table? Defaults to <code>FALSE</code>.</li>
<li><code>clean</code>: Should the original tabulated data be retained or dropped from the final table? Defaults to <code>TRUE</code>.</li>
</ul>

<h2>Examples</h2>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/multi.freq.table.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(A = sample(c(0, 1), 20, replace = TRUE), B = sample(c(0, 
    1), 20, replace = TRUE), C = sample(c(0, 1), 20, replace = TRUE), D = sample(c(0, 
    1), 20, replace = TRUE), E = sample(c(0, 1), 20, replace = TRUE))
# View your data
dat
</code></pre>

<pre><code class="no-highlight">##    A B C D E
## 1  0 1 1 1 0
## 2  0 0 1 0 1
## 3  1 1 1 0 0
## 4  1 0 1 0 0
## 5  0 0 1 1 1
## 6  1 0 1 0 0
## 7  1 0 0 0 1
## 8  1 0 0 1 0
## 9  1 1 1 0 0
## 10 0 0 1 1 0
## 11 0 0 0 0 0
## 12 0 1 1 1 0
## 13 1 0 0 0 1
## 14 0 0 0 0 1
## 15 1 1 0 0 1
## 16 0 1 0 1 1
## 17 1 1 0 1 0
## 18 1 0 1 0 0
## 19 0 1 1 1 1
## 20 1 0 0 1 1
</code></pre>

<pre><code class="r"># Apply the function with all defaults accepted
multi.freq.table(dat)
</code></pre>

<pre><code class="no-highlight">##    Combn Freq
## 1           1
## 2      A    0
## 3      B    0
## 4     AB    0
## 5      C    0
## 6     AC    3
## 7     BC    0
## 8    ABC    2
## 9      D    0
## 10    AD    1
## 11    BD    0
## 12   ABD    1
## 13    CD    1
## 14   ACD    0
## 15   BCD    2
## 16  ABCD    0
## 17     E    1
## 18    AE    2
## 19    BE    0
## 20   ABE    1
## 21    CE    1
## 22   ACE    0
## 23   BCE    0
## 24  ABCE    0
## 25    DE    0
## 26   ADE    1
## 27   BDE    1
## 28  ABDE    0
## 29   CDE    1
## 30  ACDE    0
## 31  BCDE    1
## 32 ABCDE    0
</code></pre>

<pre><code class="r"># Tabulate only on variables &#39;A&#39;, &#39;B&#39;, and &#39;D&#39;, with a different
# separator, dropping any zero frequency values, and keeping the original
# tabulations.  Note that there are no solitary &#39;B&#39; responses.
multi.freq.table(dat[c(1, 2, 4)], sep = &quot;-&quot;, dropzero = TRUE, clean = FALSE)
</code></pre>

<pre><code class="no-highlight">##   A B D Freq Combn
## 1 0 0 0    3      
## 2 1 0 0    5     A
## 4 1 1 0    3   A-B
## 5 0 0 1    2     D
## 6 1 0 1    2   A-D
## 7 0 1 1    4   B-D
## 8 1 1 1    1 A-B-D
</code></pre>

<h2>References</h2>

<p><code>apply</code> shortcut for creating the <code>Combn</code> column in the output by <a href="http://stackoverflow.com/users/906490/justin">Justin</a><br/><br/>
See: <a href="http://stackoverflow.com/q/11348391/1270695">http://stackoverflow.com/q/11348391/1270695</a></p>

<p>\newpage</p>

<h1>row.extractor</h1>

<h2>What it Does</h2>

<p>The <code>row.extractor</code> function takes a <code>data.frame</code> and extracts rows with the <code>min</code>, <code>median</code>, or <code>max</code> values of a given variable, or extracts rows with specific quantiles of a given variable.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>extract.by</code>: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.</li>
<li><code>what</code>: options are <code>min</code> (for all rows matching the minimum value), <code>median</code> (for the median row or rows), <code>max</code> (for all rows matching the maximum value), or <code>all</code> (for <code>min</code>, <code>median</code>, and <code>max</code>); alternatively, a numeric vector can be specified with the desired quantiles, for instance <code>c(0, .25, .5, .75, 1)</code></li>
</ul>

<h2>The Function</h2>

<pre><code class="r">row.extractor = function(data, extract.by, what = &quot;all&quot;) {

    if (is.numeric(extract.by)) {
        extract.by = extract.by
    } else if (is.numeric(extract.by) != 0) {
        extract.by = which(colnames(data) %in% &quot;extract.by&quot;)
    }

    if (is.character(what)) {
        which.median = function(data, extract.by) {
            a = data[, extract.by]
            if (length(a)%%2 != 0) {
                which(a == median(a))
            } else if (length(a)%%2 == 0) {
                b = sort(a)[c(length(a)/2, length(a)/2 + 1)]
                c(max(which(a == b[1])), min(which(a == b[2])))
            }
        }

        X1 = data[which(data[extract.by] == min(data[extract.by])), ]  # min
        X2 = data[which(data[extract.by] == max(data[extract.by])), ]  # max
        X3 = data[which.median(data, extract.by), ]  # median

        if (identical(what, &quot;min&quot;)) {
            X1
        } else if (identical(what, &quot;max&quot;)) {
            X2
        } else if (identical(what, &quot;median&quot;)) {
            X3
        } else if (identical(what, &quot;all&quot;)) {
            rbind(X1, X3, X2)
        }
    } else if (is.numeric(what)) {
        which.quantile &lt;- function(data, extract.by, what, na.rm = FALSE) {

            x = data[, extract.by]

            if (!na.rm &amp; any(is.na(x))) 
                return(rep(NA_integer_, length(what)))

            o &lt;- order(x)
            n &lt;- sum(!is.na(x))
            o &lt;- o[seq_len(n)]

            nppm &lt;- n * what - 0.5
            j &lt;- floor(nppm)
            h &lt;- ifelse((nppm == j) &amp; ((j%%2L) == 0L), 0, 1)
            j &lt;- j + h

            j[j == 0] &lt;- 1
            o[j]
        }
        data[which.quantile(data, extract.by, what), ]  # quantile
    }
}
</code></pre>

<h2>Examples</h2>

<pre><code class="r"># Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), V3 = round(abs(rnorm(50)), 
    digits = 2), V4 = sample(1:30, 50, replace = TRUE))
# Get a sumary of the data
summary(dat)
</code></pre>

<pre><code class="no-highlight">##        V1             V2               V3              V4       
##  Min.   : 1.0   Min.   :-2.215   Min.   :0.000   Min.   : 2.00  
##  1st Qu.:13.2   1st Qu.:-0.372   1st Qu.:0.347   1st Qu.: 8.25  
##  Median :25.5   Median : 0.129   Median :0.590   Median :13.00  
##  Mean   :25.5   Mean   : 0.100   Mean   :0.774   Mean   :14.80  
##  3rd Qu.:37.8   3rd Qu.: 0.728   3rd Qu.:1.175   3rd Qu.:20.75  
##  Max.   :50.0   Max.   : 1.595   Max.   :2.400   Max.   :29.00  
</code></pre>

<pre><code class="r"># Get the rows corresponding to the &#39;min&#39;, &#39;median&#39;, and &#39;max&#39; of &#39;V4&#39;
row.extractor(dat, 4)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 28 28 -1.4708 0.00  2
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
## 11 11  1.5118 2.40 29
## 14 14 -2.2147 0.03 29
## 18 18  0.9438 1.47 29
## 19 19  0.8212 0.15 29
## 50 50  0.8811 0.47 29
</code></pre>

<pre><code class="r"># Get the &#39;min&#39; rows only, referenced by the variable name
row.extractor(dat, &quot;V4&quot;, &quot;min&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1     V2 V3 V4
## 28 28 -1.471  0  2
</code></pre>

<pre><code class="r"># Get the &#39;median&#39; rows only. Notice that there are two rows since we have
# an even number of cases and true median is the mean of the two central
# sorted values
row.extractor(dat, &quot;V4&quot;, &quot;median&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
</code></pre>

<pre><code class="r"># Get the rows corresponding to the deciles of &#39;V3&#39;
row.extractor(dat, &quot;V3&quot;, seq(0.1, 1, 0.1))
</code></pre>

<pre><code class="no-highlight">##    V1       V2   V3 V4
## 10 10 -0.30539 0.14 22
## 26 26 -0.05613 0.29 16
## 39 39  1.10003 0.37 13
## 41 41 -0.16452 0.54 10
## 30 30  0.41794 0.59 26
## 44 44  0.55666 0.70  5
## 37 37 -0.39429 1.06 21
## 49 49 -0.11235 1.22 14
## 34 34 -0.05381 1.52 19
## 11 11  1.51178 2.40 29
</code></pre>

<h2>References</h2>

<p><code>which.quantile</code> function by <a href="http://stackoverflow.com/users/755257/cbeleites">cbeleites</a><br/><br/>
See: <a href="http://stackoverflow.com/q/10256503/1270695">http://stackoverflow.com/q/10256503/1270695</a></p>

<p>\newpage</p>

<p>\appendix</p>

<h1>The Functions</title>

<base target="_blank"/>

<style type="text/css">

body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', Consolas, 'Lucida Console', Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

.r {
   background-color: #F8F8F8;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
	border-top-style: dotted;
	border-top-color: #999999;
}

/*
 * highlight.styles.css
 *
 * RStudio style for highlight.js in HTML preview. Initial template based
 * on highlight.js VS style by JasonDiamond, tweaked to look more like
 * the default RStudio TextMate theme.
 *
 * Copyright (C) 2009-12 by RStudio, Inc.
 * Copyright (C) Jason Diamond <jason@diamond.name>
 *
 * This program is licensed to you under the terms of version 3 of the
 * GNU Affero General Public License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.
 *
 */

pre code {
  display: block; padding: 0.5em;
}

pre .operator,
pre .paren {
  color: rgb(104, 118, 135)
}

pre .literal {
  color: rgb(88, 72, 246)
}

pre .number {
  color: rgb(0, 0, 205);
}

pre .comment,
pre .annotation,
pre .template_comment,
pre .diff .header,
pre .chunk,
pre .apache .cbracket {
  color: rgb(76, 136, 107);
}

pre .keyword,
pre .id,
pre .title,
pre .built_in,
pre .aggregate,
pre .smalltalk .class,
pre .winutils,
pre .bash .variable,
pre .tex .command {
  color: rgb(0, 0, 255);
}

pre .string,
pre .title,
pre .parent,
pre .tag .value,
pre .rules .value,
pre .rules .value .number,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .instancevar,
pre .aggregate,
pre .template_tag,
pre .django .variable,
pre .addition,
pre .flow,
pre .stream,
pre .apache .tag,
pre .date,
pre .tex .formula {
  color: rgb(3, 106, 7);
}

pre .ruby .string,
pre .decorator,
pre .filter .argument,
pre .localvars,
pre .array,
pre .attr_selector,
pre .pseudo,
pre .pi,
pre .doctype,
pre .deletion,
pre .envvar,
pre .shebang,
pre .preprocessor,
pre .userType,
pre .apache .sqbracket,
pre .nginx .built_in,
pre .tex .special,
pre .input_number {
  color: rgb(43, 145, 175);
}

pre .phpdoc,
pre .javadoc,
pre .xmlDocTag {
  color: rgb(128, 159, 191);
}

pre .vhdl .type { font-weight: bold; }
pre .vhdl .string { color: #666666; }
pre .vhdl .literal { color: rgb(163, 21, 21); }




@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<script type="text/javascript">
   var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]||p=="no-highlight"){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v=="no-highlight"){return}if(v){y=d(v,x)}else{y=g(x);v=y.language}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
   hljs.initHighlightingOnLoad();  
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript">MathJax.Hub.Config({tex2jax: {processEscapes: true, processEnvironments: false, inlineMath: [ ['$','$'] ], displayMath: [ ['$$','$$'] ] }, asciimath2jax: {delimiters: [ ['$','$'] ] }, "HTML-CSS": {minScaleAdjust: 125 } });</script>

</head>

<body>
<p>% 2657 Functions<br/>
% Ananda Mahto</p>

<p>\newpage<br/>
\tableofcontents<br/>
\newpage</p>

<h1>concat.split</h1>

<h2>What it Does</h2>

<p>The <code>concat.split</code> function takes a column with multiple values, splits the values into separate columns, and returns a new <code>data.frame</code>.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>split.col</code>: the variable that needs to be split; can be specified either by the column number or the variable name.</li>
<li><code>mode</code>: can be either <code>binary</code> or <code>value</code> (where <code>binary</code> is default and it recodes values to <code>1</code> or <code>NA</code>).</li>
<li><code>sep</code>: the character separating each value (defaults to <code>&quot;,&quot;</code>).</li>
<li><code>drop.col</code>: logical (whether to remove the original variable from the output or not; defaults to <code>TRUE</code>).</li>
</ul>

<h2>Examples</h2>

<p>First load some data from a CSV stored at <a href="http://github.com">github</a>. The URL is an HTTPS, so we need to use <code>getURL</code> from <code>RCurl</code>.</p>

<pre><code class="r">require(RCurl)
</code></pre>

<pre><code class="no-highlight">## Loading required package: RCurl
</code></pre>

<pre><code class="no-highlight">## Loading required package: bitops
</code></pre>

<pre><code class="r">baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
temp = getURL(paste0(baseURL, &quot;data/concatenated-cells.csv&quot;))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
</code></pre>

<pre><code class="no-highlight">## [1] 48  4
</code></pre>

<pre><code class="r"># Just show me the first few rows
head(concat.test)
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings    Hates
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;
## 3   Dana 1,2,4,5,6                     Pierce       2;
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;
</code></pre>

<p>Notice that the data have been entered in a very silly manner. Let&#39;s split it up!</p>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/concat.split.R&quot;))))

# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings    Hates Likes_1 Likes_2
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;       1       1
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;       1       1
## 3   Dana 1,2,4,5,6                     Pierce       2;       1       1
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;       1       1
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;       1       1
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;       1       1
##   Likes_3 Likes_4 Likes_5 Likes_6
## 1      NA       1       1       1
## 2      NA       1       1       1
## 3      NA       1       1       1
## 4      NA       1       1       1
## 5      NA      NA       1       1
## 6      NA      NA       1       1
</code></pre>

<pre><code class="r"># ... or by name, and drop the offensive first column
head(concat.split(concat.test, &quot;Likes&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       1      NA
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       1      NA
## 3   Dana                     Pierce       2;       1       1      NA
## 4 Carole Colon , Michelle , Ballard     1;4;       1       1      NA
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       1      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       1      NA
##   Likes_4 Likes_5 Likes_6
## 1       1       1       1
## 2       1       1       1
## 3       1       1       1
## 4       1       1       1
## 5      NA       1       1
## 6      NA       1       1
</code></pre>

<pre><code class="r"># The &#39;Hates&#39; column uses a different separator:
head(concat.split(concat.test, &quot;Hates&quot;, sep = &quot;;&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings Hates_1 Hates_2 Hates_3
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega      NA       1      NA
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery       1       1       1
## 3   Dana 1,2,4,5,6                     Pierce      NA       1      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard       1      NA      NA
## 5 Ramona   1,2,5,6           Snyder , Joann ,       1       1       1
## 6 Kelley   1,2,5,6          James , Roxanne ,       1      NA      NA
##   Hates_4
## 1       1
## 2       1
## 3      NA
## 4       1
## 5      NA
## 6       1
</code></pre>

<pre><code class="r"># Retain the original values
head(concat.split(concat.test, 2, mode = &quot;value&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       2      NA
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       2      NA
## 3   Dana                     Pierce       2;       1       2      NA
## 4 Carole Colon , Michelle , Ballard     1;4;       1       2      NA
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       2      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       2      NA
##   Likes_4 Likes_5 Likes_6
## 1       4       5       6
## 2       4       5       6
## 3       4       5       6
## 4       4       5       6
## 5      NA       5       6
## 6      NA       5       6
</code></pre>

<pre><code class="r"># Let&#39;s try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes    Hates Siblings_1 Siblings_2 Siblings_3
## 1   Boyd 1,2,4,5,6     2;4;   Reynolds     Albert     Ortega
## 2  Rufus 1,2,4,5,6 1;2;3;4;      Cohen       Bert Montgomery
## 3   Dana 1,2,4,5,6       2;     Pierce       &lt;NA&gt;       &lt;NA&gt;
## 4 Carole 1,2,4,5,6     1;4;      Colon   Michelle    Ballard
## 5 Ramona   1,2,5,6   1;2;3;     Snyder      Joann       &lt;NA&gt;
## 6 Kelley   1,2,5,6     1;4;      James    Roxanne       &lt;NA&gt;
</code></pre>

<h2>To Do</h2>

<ul>
<li>Modify the function so that you can split multiple columns in one go?</li>
</ul>

<h2>References</h2>

<p>See: <a href="http://stackoverflow.com/q/10100887/1270695">http://stackoverflow.com/q/10100887/1270695</a></p>

<p>\newpage</p>

<h1>df.sorter</h1>

<h2>What it Does</h2>

<p>The <code>df.sorter</code> function allows you to sort a <code>data.frame</code> by columns or rows or both. You can also quickly subset data solums by using the <code>var.order</code> argument.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>var.order</code>: the new order in which you want the variables to appear.

<ul>
<li>Defaults to <code>names(data)</code>, which keeps the variables in the original order.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).</li>
<li>Basic subsetting can also be done using <code>var.order</code> simply by omitting the variables you want to drop.</li>
</ul></li>
<li><code>col.sort</code>: the columns <em>within</em> which there is data that need to be sorted.

<ul>
<li>Defaults to <code>NULL</code>, which means no sorting takes place.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.</li>
</ul></li>
<li><code>at.start</code>: Should the pattern matching be from the start of the variable name? Defaults to &ldquo;TRUE&rdquo;.</li>
</ul>

<blockquote>
<p>NOTE: If you are sorting both by variables and within the columns, the <code>col.sort</code> order should be based on the location of the columns in the <em>new</em> <code>data.frame</code>, not the original <code>data.frame</code>.</p>
</blockquote>

<h2>Examples</h2>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/df.sorter.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each = 3), times = rep(1:3, 5), measure1 = rnorm(15), 
    score1 = sample(300, 15), code1 = replicate(15, paste(sample(LETTERS[1:5], 
        3), sep = &quot;&quot;, collapse = &quot;&quot;)), measure2 = rnorm(15), score2 = sample(150:300, 
        15), code2 = replicate(15, paste(sample(LETTERS[1:5], 3), sep = &quot;&quot;, 
        collapse = &quot;&quot;)))
# Preview your data
dat
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
## 3   1     3  -0.8356    148   EBA   0.7685    222   DAE
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
## 6   2     3  -0.8205    198   EBD   0.3981    216   DCA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 9   3     3   0.5758    212   EBC  -1.1294    182   BEC
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 11  4     2   1.5118    239   EDB   1.9804    231   CAB
## 12  4     3   0.3898    188   DEB  -0.3672    160   DBE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 14  5     2  -2.2147    159   DAC   0.5697    238   BDE
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
</code></pre>

<pre><code class="r"># Change the variable order, grouping related columns Note that you do not
# need to specify full variable names, just enough that the variables can
# be uniquely identified
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;ti&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># As above, but sorted by &#39;times&#39; and then &#39;id&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;), 
    col.sort = c(2, 1)))
</code></pre>

<pre><code class="no-highlight">##    id times code1 code2 measure1 measure2 score1 score2
## 1   1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 4   2     1   AED   DBA   1.5953  -0.1123     56    175
## 7   3     1   BCA   CEA   0.4874  -0.6120    234    300
## 10  4     1   BED   CDE  -0.3054   1.4330    120    234
## 13  5     1   DBA   EDB  -0.6212  -1.0441    226    154
## 2   1     2   DCB   ECD   0.1836   0.3646    180    224
</code></pre>

<pre><code class="r"># Drop &#39;measure1&#39; and &#39;measure2&#39;, sort by &#39;times&#39;, and &#39;score1&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(2, 
    3)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># As above, but using names
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(&quot;times&quot;, 
    &quot;score1&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># Just sort by columns, first by &#39;times&#39; then by &#39;id&#39;
head(df.sorter(dat, col.sort = c(&quot;times&quot;, &quot;id&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
</code></pre>

<pre><code class="r">head(df.sorter(dat, col.sort = c(&quot;code1&quot;)))  # Sorting by character values
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
</code></pre>

<pre><code class="r"># Pattern matching anywhere in the variable name
head(df.sorter(dat, var.order = &quot;co&quot;, at.start = FALSE))
</code></pre>

<pre><code class="no-highlight">##   code1 code2 score1 score2
## 1   DAB   CEB    145    299
## 2   DCB   ECD    180    224
## 3   EBA   DAE    148    222
## 4   AED   DBA     56    175
## 5   CEB   DAC    245    260
## 6   EBD   DCA    198    216
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add an option to sort ascending or descending&mdash;at the moment, not supported.</li>
</ul>

<p>\newpage</p>

<h1>multi.freq.table</h1>

<h2>What it Does</h2>

<p>The <code>multi.freq.table</code> function takes a data frame containing boolean responses to multiple response questions and tabulates the number of responses by the possible combinations of answers.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: The multiple responses that need to be tabulated.</li>
<li><code>sep</code>: The desired separator for collapsing the combinations of options; defaults to <code>&quot;&quot;</code> (collapsing with no space between each option name).</li>
<li><code>dropzero</code>: Should combinations with a frequency of zero be dropped from the final table? Defaults to <code>FALSE</code>.</li>
<li><code>clean</code>: Should the original tabulated data be retained or dropped from the final table? Defaults to <code>TRUE</code>.</li>
</ul>

<h2>Examples</h2>

<pre><code class="r"># Load the function!  require(RCurl) baseURL =
# c(&#39;https://raw.github.com/mrdwab/2657-R-Functions/master/&#39;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/multi.freq.table.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(A = sample(c(0, 1), 20, replace = TRUE), B = sample(c(0, 
    1), 20, replace = TRUE), C = sample(c(0, 1), 20, replace = TRUE), D = sample(c(0, 
    1), 20, replace = TRUE), E = sample(c(0, 1), 20, replace = TRUE))
# View your data
dat
</code></pre>

<pre><code class="no-highlight">##    A B C D E
## 1  0 1 1 1 0
## 2  0 0 1 0 1
## 3  1 1 1 0 0
## 4  1 0 1 0 0
## 5  0 0 1 1 1
## 6  1 0 1 0 0
## 7  1 0 0 0 1
## 8  1 0 0 1 0
## 9  1 1 1 0 0
## 10 0 0 1 1 0
## 11 0 0 0 0 0
## 12 0 1 1 1 0
## 13 1 0 0 0 1
## 14 0 0 0 0 1
## 15 1 1 0 0 1
## 16 0 1 0 1 1
## 17 1 1 0 1 0
## 18 1 0 1 0 0
## 19 0 1 1 1 1
## 20 1 0 0 1 1
</code></pre>

<pre><code class="r"># Apply the function with all defaults accepted
multi.freq.table(dat)
</code></pre>

<pre><code class="no-highlight">##    Combn Freq
## 1           1
## 2      A    0
## 3      B    0
## 4     AB    0
## 5      C    0
## 6     AC    3
## 7     BC    0
## 8    ABC    2
## 9      D    0
## 10    AD    1
## 11    BD    0
## 12   ABD    1
## 13    CD    1
## 14   ACD    0
## 15   BCD    2
## 16  ABCD    0
## 17     E    1
## 18    AE    2
## 19    BE    0
## 20   ABE    1
## 21    CE    1
## 22   ACE    0
## 23   BCE    0
## 24  ABCE    0
## 25    DE    0
## 26   ADE    1
## 27   BDE    1
## 28  ABDE    0
## 29   CDE    1
## 30  ACDE    0
## 31  BCDE    1
## 32 ABCDE    0
</code></pre>

<pre><code class="r"># Tabulate only on variables &#39;A&#39;, &#39;B&#39;, and &#39;D&#39;, with a different
# separator, dropping any zero frequency values, and keeping the original
# tabulations.  Note that there are no solitary &#39;B&#39; responses.
multi.freq.table(dat[c(1, 2, 4)], sep = &quot;-&quot;, dropzero = TRUE, clean = FALSE)
</code></pre>

<pre><code class="no-highlight">##   A B D Freq Combn
## 1 0 0 0    3      
## 2 1 0 0    5     A
## 4 1 1 0    3   A-B
## 5 0 0 1    2     D
## 6 1 0 1    2   A-D
## 7 0 1 1    4   B-D
## 8 1 1 1    1 A-B-D
</code></pre>

<h2>References</h2>

<p><code>apply</code> shortcut for creating the <code>Combn</code> column in the output by <a href="http://stackoverflow.com/users/906490/justin">Justin</a><br/><br/>
See: <a href="http://stackoverflow.com/q/11348391/1270695">http://stackoverflow.com/q/11348391/1270695</a></p>

<p>\newpage</p>

<h1>row.extractor</h1>

<h2>What it Does</h2>

<p>The <code>row.extractor</code> function takes a <code>data.frame</code> and extracts rows with the <code>min</code>, <code>median</code>, or <code>max</code> values of a given variable, or extracts rows with specific quantiles of a given variable.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>extract.by</code>: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.</li>
<li><code>what</code>: options are <code>min</code> (for all rows matching the minimum value), <code>median</code> (for the median row or rows), <code>max</code> (for all rows matching the maximum value), or <code>all</code> (for <code>min</code>, <code>median</code>, and <code>max</code>); alternatively, a numeric vector can be specified with the desired quantiles, for instance <code>c(0, .25, .5, .75, 1)</code></li>
</ul>

<h2>The Function</h2>

<pre><code class="r">row.extractor = function(data, extract.by, what = &quot;all&quot;) {

    if (is.numeric(extract.by)) {
        extract.by = extract.by
    } else if (is.numeric(extract.by) != 0) {
        extract.by = which(colnames(data) %in% &quot;extract.by&quot;)
    }

    if (is.character(what)) {
        which.median = function(data, extract.by) {
            a = data[, extract.by]
            if (length(a)%%2 != 0) {
                which(a == median(a))
            } else if (length(a)%%2 == 0) {
                b = sort(a)[c(length(a)/2, length(a)/2 + 1)]
                c(max(which(a == b[1])), min(which(a == b[2])))
            }
        }

        X1 = data[which(data[extract.by] == min(data[extract.by])), ]  # min
        X2 = data[which(data[extract.by] == max(data[extract.by])), ]  # max
        X3 = data[which.median(data, extract.by), ]  # median

        if (identical(what, &quot;min&quot;)) {
            X1
        } else if (identical(what, &quot;max&quot;)) {
            X2
        } else if (identical(what, &quot;median&quot;)) {
            X3
        } else if (identical(what, &quot;all&quot;)) {
            rbind(X1, X3, X2)
        }
    } else if (is.numeric(what)) {
        which.quantile &lt;- function(data, extract.by, what, na.rm = FALSE) {

            x = data[, extract.by]

            if (!na.rm &amp; any(is.na(x))) 
                return(rep(NA_integer_, length(what)))

            o &lt;- order(x)
            n &lt;- sum(!is.na(x))
            o &lt;- o[seq_len(n)]

            nppm &lt;- n * what - 0.5
            j &lt;- floor(nppm)
            h &lt;- ifelse((nppm == j) &amp; ((j%%2L) == 0L), 0, 1)
            j &lt;- j + h

            j[j == 0] &lt;- 1
            o[j]
        }
        data[which.quantile(data, extract.by, what), ]  # quantile
    }
}
</code></pre>

<h2>Examples</h2>

<pre><code class="r"># Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), V3 = round(abs(rnorm(50)), 
    digits = 2), V4 = sample(1:30, 50, replace = TRUE))
# Get a sumary of the data
summary(dat)
</code></pre>

<pre><code class="no-highlight">##        V1             V2               V3              V4       
##  Min.   : 1.0   Min.   :-2.215   Min.   :0.000   Min.   : 2.00  
##  1st Qu.:13.2   1st Qu.:-0.372   1st Qu.:0.347   1st Qu.: 8.25  
##  Median :25.5   Median : 0.129   Median :0.590   Median :13.00  
##  Mean   :25.5   Mean   : 0.100   Mean   :0.774   Mean   :14.80  
##  3rd Qu.:37.8   3rd Qu.: 0.728   3rd Qu.:1.175   3rd Qu.:20.75  
##  Max.   :50.0   Max.   : 1.595   Max.   :2.400   Max.   :29.00  
</code></pre>

<pre><code class="r"># Get the rows corresponding to the &#39;min&#39;, &#39;median&#39;, and &#39;max&#39; of &#39;V4&#39;
row.extractor(dat, 4)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 28 28 -1.4708 0.00  2
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
## 11 11  1.5118 2.40 29
## 14 14 -2.2147 0.03 29
## 18 18  0.9438 1.47 29
## 19 19  0.8212 0.15 29
## 50 50  0.8811 0.47 29
</code></pre>

<pre><code class="r"># Get the &#39;min&#39; rows only, referenced by the variable name
row.extractor(dat, &quot;V4&quot;, &quot;min&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1     V2 V3 V4
## 28 28 -1.471  0  2
</code></pre>

<pre><code class="r"># Get the &#39;median&#39; rows only. Notice that there are two rows since we have
# an even number of cases and true median is the mean of the two central
# sorted values
row.extractor(dat, &quot;V4&quot;, &quot;median&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
</code></pre>

<pre><code class="r"># Get the rows corresponding to the deciles of &#39;V3&#39;
row.extractor(dat, &quot;V3&quot;, seq(0.1, 1, 0.1))
</code></pre>

<pre><code class="no-highlight">##    V1       V2   V3 V4
## 10 10 -0.30539 0.14 22
## 26 26 -0.05613 0.29 16
## 39 39  1.10003 0.37 13
## 41 41 -0.16452 0.54 10
## 30 30  0.41794 0.59 26
## 44 44  0.55666 0.70  5
## 37 37 -0.39429 1.06 21
## 49 49 -0.11235 1.22 14
## 34 34 -0.05381 1.52 19
## 11 11  1.51178 2.40 29
</code></pre>

<h2>References</h2>

<p><code>which.quantile</code> function by <a href="http://stackoverflow.com/users/755257/cbeleites">cbeleites</a><br/><br/>
See: <a href="http://stackoverflow.com/q/10256503/1270695">http://stackoverflow.com/q/10256503/1270695</a></p>

<p>\newpage</p>

<p>\appendix</p>

<h1>The Functions</h1>

<p>The most current source code for the functions described in this document follow.</p>

<p>To load the functions, you can directly source them from the 2657 R Functions page at github: <a href="https://github.com/mrdwab/2657-R-Functions">https://github.com/mrdwab/2657-R-Functions</a></p>

<p>You should be able to load the functions using the following (replace <code>-----------</code> with the function name):</p>

<pre><code class="r">require(RCurl)
baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/-----------.R&quot;))))
</code></pre>

<p>\newpage</p>

<h2>concat.split</h2>

<pre><code class="no-highlight">concat.split = function(data, split.col, mode=NULL, 
                        sep=&quot;,&quot;, drop.col=FALSE) {
  # Takes a column with multiple values, splits the values into 
  #   separate columns, and returns a new data.frame.
  # &#39;data&#39; is the source data.frame; &#39;split.col&#39; is the variable that 
  #   needs to be split; &#39;mode&#39; can be either &#39;binary&#39; or &#39;value&#39; 
  #   (where &#39;binary&#39; is default and it recodes values to 1 or NA);
  #   &#39;sep&#39; is the character separating each value (defaults to &#39;,&#39;); 
  #   and &#39;drop.col&#39; is logical (whether to remove the original 
  #   variable from the output or not.
  #
  # === EXAMPLES ===
  #
  #       dat = data.frame(V1 = c(&quot;1, 2, 4&quot;, &quot;3, 4, 5&quot;, 
  #                               &quot;1, 2, 5&quot;, &quot;4&quot;, &quot;1, 2, 3, 5&quot;),
  #                        V2 = c(&quot;1;2;3;4&quot;, &quot;1&quot;, &quot;2;5&quot;, 
  #                               &quot;3;2&quot;, &quot;2;3;4&quot;))
  #       dat2 = data.frame(V1 = c(&quot;Fred, John, Sue&quot;, &quot;Jerry, Jill&quot;, 
  #                                &quot;Sally, Ryan&quot;, &quot;Susan, Amos, Ben&quot;))
  #
  #       concat.split(dat, 1) 
  #       concat.split(dat, 2, sep=&quot;;&quot;)
  #       concat.split(dat, &quot;V2&quot;, sep=&quot;;&quot;, mode=&quot;value&quot;)
  #       concat.split(dat, &quot;V1&quot;, mode=&quot;binary&quot;)
  #       concat.split(dat2, 1)
  #       concat.split(dat2, &quot;V1&quot;, drop.col=TRUE)
  #
  # See: http://stackoverflow.com/q/10100887/1270695

  if (is.numeric(split.col)) split.col = split.col
  else split.col = which(colnames(data) %in% split.col)

  a = as.character(data[ , split.col])
  b = strsplit(a, sep)

  if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
    what = &quot;string&quot;
    ncol = max(unlist(lapply(b, function(i) length(i))))
  } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
    what = &quot;numeric&quot;
    ncol = max(as.numeric(unlist(b)))
  }

  m = matrix(nrow = nrow(data), ncol = ncol)
  v = vector(&quot;list&quot;, nrow(data))

  if (identical(what, &quot;string&quot;)) {
    temp = as.data.frame(t(sapply(b, &#39;[&#39;, 1:ncol)))
    names(temp) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep=&quot;&quot;)
    temp = apply(temp, 2, function(x) gsub(&quot;^\\s+|\\s+$&quot;, &quot;&quot;, x))
    temp1 = cbind(data, temp)
  } else if (identical(what, &quot;numeric&quot;)) {
    for (i in 1:nrow(data)) {
      v[[i]] = as.numeric(strsplit(a, sep)[[i]])
    }

    temp = v

    for (i in 1:nrow(data)) {
      m[i, temp[[i]]] = temp[[i]]
    }

    m = data.frame(m)
    names(m) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep=&quot;&quot;)

    if (is.null(mode) || identical(mode, &quot;binary&quot;)) {
      temp1 = cbind(data, replace(m, m != &quot;NA&quot;, 1))
    } else if (identical(mode, &quot;value&quot;)) {
      temp1 = cbind(data, m)
    }
  } 

  if (isTRUE(drop.col)) temp1[-split.col]
  else temp1

}
</code></pre>

<p>\newpage</p>

<h2>df.sorter</h2>

<pre><code class="no-highlight">df.sorter = function(data, var.order=names(data), col.sort=NULL, at.start=TRUE ) {
  # Sorts a data.frame by columns or rows or both.
  # Can also subset the data columns by using &#39;var.order&#39;.
  # Can refer to variables either by names or number.
  # If referring to variable by number, and sorting both the order
  #   of variables and the sorting within variables, refer to the
  #   variable numbers of the final data.frame.
  #
  # === EXAMPLES ===
  #
  #    library(foreign)
  #    temp = &quot;http://www.ats.ucla.edu/stat/stata/modules/kidshtwt.dta&quot;
  #    kidshtwt = read.dta(temp); rm(temp)
  #    df.sorter(kidshtwt, var.order = c(&quot;fam&quot;, &quot;bir&quot;, &quot;wt&quot;, &quot;ht&quot;))
  #    df.sorter(kidshtwt, var.order = c(&quot;fam&quot;, &quot;bir&quot;, &quot;wt&quot;, &quot;ht&quot;),
  #              col.sort = c(&quot;birth&quot;, &quot;famid&quot;)) # USE FULL NAMES HERE
  #    df.sorter(kidshtwt, var.order = c(1:4),   # DROP THE WT COLUMNS
  #              col.sort = 3)                   # SORT BY HT1  

  if (is.numeric(var.order)) 
    var.order = colnames(data)[var.order]
  else var.order = var.order

  a = names(data)
  b = length(var.order)
  subs = vector(&quot;list&quot;, b)

  if (isTRUE(at.start)) {
    for (i in 1:b) {
      subs[[i]] = sort(grep(paste(&quot;^&quot;, var.order[i],
                                  sep=&quot;&quot;, collapse=&quot;&quot;),
                            a, value=TRUE))
    }  
  } else if (!isTRUE(at.start)) {
    for (i in 1:b) {
      subs[[i]] = sort(grep(var.order[i], a, value=TRUE))
    }
  }

  x = unlist(subs)
  y = data[ , x ]

  if (is.null(col.sort)) {
    y
  } else if (is.numeric(col.sort)) {
    col.sort = colnames(y)[col.sort]
    y[do.call(order, y[col.sort]), ]
  } else if (!is.numeric(col.sort)) {
    col.sort = col.sort
    y[do.call(order, y[col.sort]), ]
  }
}
</code></pre>

<p>\newpage</p>

<h2>multi.freq.table</h2>

<pre><code class="no-highlight">multi.freq.table = function(data, sep=&quot;&quot;, dropzero=FALSE, clean=TRUE) {
  # Takes boolean multiple-response data and tabulates it according
  #   to the possible combinations of each variable.
  #
  # === EXAMPLES ===
  #     set.seed(1)
  #     dat = data.frame(A = sample(c(0, 1), 20, replace=TRUE), 
  #                      B = sample(c(0, 1), 20, replace=TRUE), 
  #                      C = sample(c(0, 1), 20, replace=TRUE),
  #                      D = sample(c(0, 1), 20, replace=TRUE),
  #                      E = sample(c(0, 1), 20, replace=TRUE))
  #   multi.freq.table(dat)
  #   multi.freq.table(dat[1:3], sep=&quot;-&quot;, dropzero=TRUE)
  #
  # See: http://stackoverflow.com/q/11348391/1270695

  counts = data.frame(table(data))
  N = ncol(counts)
  counts$Combn = apply(counts[-N] == 1, 1, 
                       function(x) paste(names(counts[-N])[x],
                                         collapse=sep))
  if (isTRUE(dropzero)) {
    counts = counts[counts$Freq != 0, ]
  } else if (!isTRUE(dropzero)) {
    counts = counts
  }
  if (isTRUE(clean)) {
    counts = data.frame(Combn = counts$Combn, Freq = counts$Freq)
  } 
  counts
}
</code></pre>

</body>

</html>

