<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>concat.split</h1>

<h2>What it Does</h2>

<p>The <code>concat.split</code> function takes a column with multiple values, splits the values into separate columns, and returns a new <code>data.frame</code>.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>split.col</code>: the variable that needs to be split; can be specified either by the column number or the variable name.</li>
<li><code>mode</code>: can be either <code>binary</code> or <code>value</code> (where <code>binary</code> is default and it recodes values to <code>1</code> or <code>NA</code>).</li>
<li><code>sep</code>: the character separating each value (defaults to <code>&quot;,&quot;</code>).</li>
<li><code>drop.col</code>: logical (whether to remove the original variable from the output or not; defaults to <code>TRUE</code>).</li>
</ul>

<h2>The Function</h2>

<pre><code class="r">concat.split = function(data, split.col, mode = NULL, sep = &quot;,&quot;, 
    drop.col = FALSE) {

    if (is.numeric(split.col)) 
        split.col = split.col else split.col = which(colnames(data) %in% split.col)

    a = as.character(data[, split.col])
    b = strsplit(a, sep)

    if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
        what = &quot;string&quot;
        ncol = max(unlist(lapply(b, function(i) length(i))))
    } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
        what = &quot;numeric&quot;
        ncol = max(as.numeric(unlist(b)))
    }

    m = matrix(nrow = nrow(data), ncol = ncol)
    v = vector(&quot;list&quot;, nrow(data))

    if (identical(what, &quot;string&quot;)) {
        temp = as.data.frame(t(sapply(b, &quot;[&quot;, 1:ncol)))
        names(temp) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep = &quot;&quot;)
        temp1 = cbind(data, temp)
    } else if (identical(what, &quot;numeric&quot;)) {
        for (i in 1:nrow(data)) {
            v[[i]] = as.numeric(strsplit(a, sep)[[i]])
        }

        temp = v

        for (i in 1:nrow(data)) {
            m[i, temp[[i]]] = temp[[i]]
        }

        m = data.frame(m)
        names(m) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep = &quot;&quot;)

        if (is.null(mode) || identical(mode, &quot;binary&quot;)) {
            temp1 = cbind(data, replace(m, m != &quot;NA&quot;, 1))
        } else if (identical(mode, &quot;value&quot;)) {
            temp1 = cbind(data, m)
        }
    }

    if (isTRUE(drop.col)) 
        temp1[-split.col] else temp1

}
</code></pre>

<h2>Examples</h2>

<p>First load some data from a CSV stored at <a href="http://github.com">github</a>. The URL is an HTTPS, so we need to use <code>getURL</code> from <code>RCurl</code>.</p>

<pre><code class="r">require(RCurl)
</code></pre>

<pre><code class="no-highlight">## Loading required package: RCurl
</code></pre>

<pre><code class="no-highlight">## Loading required package: bitops
</code></pre>

<pre><code class="r">baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
temp = getURL(paste0(baseURL, &quot;data/concatenated-cells.csv&quot;))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
</code></pre>

<pre><code class="no-highlight">## [1] 48  3
</code></pre>

<pre><code class="r"># Just show me the first few rows
head(concat.test)
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery
## 3   Dana 1,2,4,5,6                     Pierce
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard
## 5 Ramona   1,2,5,6           Snyder , Joann ,
## 6 Kelley   1,2,5,6          James , Roxanne ,
</code></pre>

<p>Notice that the data have been entered in a very silly manner. Let&#39;s split it up!</p>

<pre><code class="r"># Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings Likes_1 Likes_2 Likes_3
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega       1       1      NA
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery       1       1      NA
## 3   Dana 1,2,4,5,6                     Pierce       1       1      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard       1       1      NA
## 5 Ramona   1,2,5,6           Snyder , Joann ,       1       1      NA
## 6 Kelley   1,2,5,6          James , Roxanne ,       1       1      NA
##   Likes_4 Likes_5 Likes_6
## 1       1       1       1
## 2       1       1       1
## 3       1       1       1
## 4       1       1       1
## 5      NA       1       1
## 6      NA       1       1
</code></pre>

<pre><code class="r"># ... or by name, and drop the offensive first column
head(concat.split(concat.test, &quot;Likes&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega       1       1      NA       1
## 2  Rufus  Cohen , Bert , Montgomery       1       1      NA       1
## 3   Dana                     Pierce       1       1      NA       1
## 4 Carole Colon , Michelle , Ballard       1       1      NA       1
## 5 Ramona           Snyder , Joann ,       1       1      NA      NA
## 6 Kelley          James , Roxanne ,       1       1      NA      NA
##   Likes_5 Likes_6
## 1       1       1
## 2       1       1
## 3       1       1
## 4       1       1
## 5       1       1
## 6       1       1
</code></pre>

<pre><code class="r"># Retain the original values
head(concat.split(concat.test, 2, mode = &quot;value&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega       1       2      NA       4
## 2  Rufus  Cohen , Bert , Montgomery       1       2      NA       4
## 3   Dana                     Pierce       1       2      NA       4
## 4 Carole Colon , Michelle , Ballard       1       2      NA       4
## 5 Ramona           Snyder , Joann ,       1       2      NA      NA
## 6 Kelley          James , Roxanne ,       1       2      NA      NA
##   Likes_5 Likes_6
## 1       5       6
## 2       5       6
## 3       5       6
## 4       5       6
## 5       5       6
## 6       5       6
</code></pre>

<pre><code class="r"># Let&#39;s try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes Siblings_1 Siblings_2  Siblings_3
## 1   Boyd 1,2,4,5,6  Reynolds     Albert       Ortega
## 2  Rufus 1,2,4,5,6     Cohen       Bert   Montgomery
## 3   Dana 1,2,4,5,6     Pierce       &lt;NA&gt;        &lt;NA&gt;
## 4 Carole 1,2,4,5,6     Colon   Michelle      Ballard
## 5 Ramona   1,2,5,6    Snyder      Joann         &lt;NA&gt;
## 6 Kelley   1,2,5,6     James    Roxanne         &lt;NA&gt;
</code></pre>

<h2>To Do</h2>

<ul>
<li>Modify the function so that you can split multiple columns in one go?</li>
<li>Strip whitespace from string output.</li>
</ul>

<h2>References</h2>

<p>See: <a href="http://stackoverflow.com/q/10100887/1270695">http://stackoverflow.com/q/10100887/1270695</a></p>

<p>\newpage</p>

<h1>df.sorter</h1>

<h2>What it Does</h2>

<p>The <code>df.sorter</code> function allows you to sort a <code>data.frame</code> by columns or rows or both. You can also quickly subset data solums by using the <code>var.order</code> argument.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>var.order</code>: the new order in which you want the variables to appear.

<ul>
<li>Defaults to <code>names(data)</code>, which keeps the variables in the original order.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).</li>
<li>Basic subsetting can also be done using <code>var.order</code> simply by omitting the variables you want to drop.</li>
</ul></li>
<li><code>col.sort</code>: the columns <em>within</em> which there is data that need to be sorted.

<ul>
<li>Defaults to <code>NULL</code>, which means no sorting takes place.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.</li>
</ul></li>
</ul>

<blockquote>
<p>NOTE: If you are sorting both by variables and within the columns, the <code>col.sort</code> order should be based on the location of the columns in the <em>new</em> <code>data.frame</code>, not the original <code>data.frame</code>.</p>
</blockquote>

<h2>The Function</h2>

<pre><code class="r">df.sorter = function(data, var.order = names(data), col.sort = NULL) {

    if (is.numeric(var.order)) 
        var.order = colnames(data)[var.order] else var.order = var.order

    a = names(data)
    b = length(var.order)
    subs = vector(&quot;list&quot;, b)

    for (i in 1:b) {
        subs[[i]] = sort(grep(var.order[i], a, value = TRUE))
    }
    x = unlist(subs)
    y = data[, x]

    if (is.null(col.sort)) {
        y
    } else if (is.numeric(col.sort)) {
        col.sort = colnames(y)[col.sort]
        y[do.call(order, y[col.sort]), ]
    } else if (!is.numeric(col.sort)) {
        col.sort = col.sort
        y[do.call(order, y[col.sort]), ]
    }
}
</code></pre>

<h2>Examples</h2>

<pre><code class="r"># Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each = 3), times = rep(1:3, 5), measure1 = rnorm(15), 
    score1 = sample(300, 15), code1 = replicate(15, paste(sample(LETTERS[1:5], 
        3), sep = &quot;&quot;, collapse = &quot;&quot;)), measure2 = rnorm(15), score2 = sample(150:300, 
        15), code2 = replicate(15, paste(sample(LETTERS[1:5], 3), sep = &quot;&quot;, 
        collapse = &quot;&quot;)))
# Preview your data
dat
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
## 3   1     3  -0.8356    148   EBA   0.7685    222   DAE
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
## 6   2     3  -0.8205    198   EBD   0.3981    216   DCA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 9   3     3   0.5758    212   EBC  -1.1294    182   BEC
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 11  4     2   1.5118    239   EDB   1.9804    231   CAB
## 12  4     3   0.3898    188   DEB  -0.3672    160   DBE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 14  5     2  -2.2147    159   DAC   0.5697    238   BDE
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
</code></pre>

<pre><code class="r"># Change the variable order, grouping related columns Note that you do not
# need to specify full variable names, just enough that the variables can
# be uniquely identified
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;ti&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># As above, but sorted by &#39;times&#39; and then &#39;id&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;), 
    col.sort = c(2, 1)))
</code></pre>

<pre><code class="no-highlight">##    id times code1 code2 measure1 measure2 score1 score2
## 1   1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 4   2     1   AED   DBA   1.5953  -0.1123     56    175
## 7   3     1   BCA   CEA   0.4874  -0.6120    234    300
## 10  4     1   BED   CDE  -0.3054   1.4330    120    234
## 13  5     1   DBA   EDB  -0.6212  -1.0441    226    154
## 2   1     2   DCB   ECD   0.1836   0.3646    180    224
</code></pre>

<pre><code class="r"># Drop &#39;measure1&#39; and &#39;measure2&#39;, sort by &#39;times&#39;, and &#39;score1&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(2, 
    3)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># As above, but using names
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(&quot;times&quot;, 
    &quot;score1&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># Just sort by columns, first by &#39;times&#39; then by &#39;id&#39;
head(df.sorter(dat, col.sort = c(&quot;times&quot;, &quot;id&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
</code></pre>

<pre><code class="r">head(df.sorter(dat, col.sort = c(&quot;code1&quot;)))  # Sorting by character values
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add an option to sort ascending or descending&mdash;at the moment, not supported.</li>
<li>Modify the <code>grep</code> function for <code>var.order</code> to only match strings from the start of a variable name.</li>
</ul>

<p>\newpage</p>

<h1>row.extractor</title>

<base target="_blank"/>

<style type="text/css">

body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', Consolas, 'Lucida Console', Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

.r {
   background-color: #F8F8F8;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
	border-top-style: dotted;
	border-top-color: #999999;
}

/*
 * highlight.styles.css
 *
 * RStudio style for highlight.js in HTML preview. Initial template based
 * on highlight.js VS style by JasonDiamond, tweaked to look more like
 * the default RStudio TextMate theme.
 *
 * Copyright (C) 2009-12 by RStudio, Inc.
 * Copyright (C) Jason Diamond <jason@diamond.name>
 *
 * This program is licensed to you under the terms of version 3 of the
 * GNU Affero General Public License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.
 *
 */

pre code {
  display: block; padding: 0.5em;
}

pre .operator,
pre .paren {
  color: rgb(104, 118, 135)
}

pre .literal {
  color: rgb(88, 72, 246)
}

pre .number {
  color: rgb(0, 0, 205);
}

pre .comment,
pre .annotation,
pre .template_comment,
pre .diff .header,
pre .chunk,
pre .apache .cbracket {
  color: rgb(76, 136, 107);
}

pre .keyword,
pre .id,
pre .title,
pre .built_in,
pre .aggregate,
pre .smalltalk .class,
pre .winutils,
pre .bash .variable,
pre .tex .command {
  color: rgb(0, 0, 255);
}

pre .string,
pre .title,
pre .parent,
pre .tag .value,
pre .rules .value,
pre .rules .value .number,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .instancevar,
pre .aggregate,
pre .template_tag,
pre .django .variable,
pre .addition,
pre .flow,
pre .stream,
pre .apache .tag,
pre .date,
pre .tex .formula {
  color: rgb(3, 106, 7);
}

pre .ruby .string,
pre .decorator,
pre .filter .argument,
pre .localvars,
pre .array,
pre .attr_selector,
pre .pseudo,
pre .pi,
pre .doctype,
pre .deletion,
pre .envvar,
pre .shebang,
pre .preprocessor,
pre .userType,
pre .apache .sqbracket,
pre .nginx .built_in,
pre .tex .special,
pre .input_number {
  color: rgb(43, 145, 175);
}

pre .phpdoc,
pre .javadoc,
pre .xmlDocTag {
  color: rgb(128, 159, 191);
}

pre .vhdl .type { font-weight: bold; }
pre .vhdl .string { color: #666666; }
pre .vhdl .literal { color: rgb(163, 21, 21); }




@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<script type="text/javascript">
   var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]||p=="no-highlight"){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v=="no-highlight"){return}if(v){y=d(v,x)}else{y=g(x);v=y.language}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
   hljs.initHighlightingOnLoad();  
</script>



</head>

<body>
<p>% 2657 Functions<br/>
% Ananda Mahto</p>

<p>\newpage<br/>
\toc</p>

<h1>concat.split</h1>

<h2>What it Does</h2>

<p>The <code>concat.split</code> function takes a column with multiple values, splits the values into separate columns, and returns a new <code>data.frame</code>.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>split.col</code>: the variable that needs to be split; can be specified either by the column number or the variable name.</li>
<li><code>mode</code>: can be either <code>binary</code> or <code>value</code> (where <code>binary</code> is default and it recodes values to <code>1</code> or <code>NA</code>).</li>
<li><code>sep</code>: the character separating each value (defaults to <code>&quot;,&quot;</code>).</li>
<li><code>drop.col</code>: logical (whether to remove the original variable from the output or not; defaults to <code>TRUE</code>).</li>
</ul>

<h2>The Function</h2>

<pre><code class="r">concat.split = function(data, split.col, mode = NULL, sep = &quot;,&quot;, 
    drop.col = FALSE) {

    if (is.numeric(split.col)) 
        split.col = split.col else split.col = which(colnames(data) %in% split.col)

    a = as.character(data[, split.col])
    b = strsplit(a, sep)

    if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
        what = &quot;string&quot;
        ncol = max(unlist(lapply(b, function(i) length(i))))
    } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
        what = &quot;numeric&quot;
        ncol = max(as.numeric(unlist(b)))
    }

    m = matrix(nrow = nrow(data), ncol = ncol)
    v = vector(&quot;list&quot;, nrow(data))

    if (identical(what, &quot;string&quot;)) {
        temp = as.data.frame(t(sapply(b, &quot;[&quot;, 1:ncol)))
        names(temp) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep = &quot;&quot;)
        temp1 = cbind(data, temp)
    } else if (identical(what, &quot;numeric&quot;)) {
        for (i in 1:nrow(data)) {
            v[[i]] = as.numeric(strsplit(a, sep)[[i]])
        }

        temp = v

        for (i in 1:nrow(data)) {
            m[i, temp[[i]]] = temp[[i]]
        }

        m = data.frame(m)
        names(m) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep = &quot;&quot;)

        if (is.null(mode) || identical(mode, &quot;binary&quot;)) {
            temp1 = cbind(data, replace(m, m != &quot;NA&quot;, 1))
        } else if (identical(mode, &quot;value&quot;)) {
            temp1 = cbind(data, m)
        }
    }

    if (isTRUE(drop.col)) 
        temp1[-split.col] else temp1

}
</code></pre>

<h2>Examples</h2>

<p>First load some data from a CSV stored at <a href="http://github.com">github</a>. The URL is an HTTPS, so we need to use <code>getURL</code> from <code>RCurl</code>.</p>

<pre><code class="r">require(RCurl)
</code></pre>

<pre><code class="no-highlight">## Loading required package: RCurl
</code></pre>

<pre><code class="no-highlight">## Loading required package: bitops
</code></pre>

<pre><code class="r">baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
temp = getURL(paste0(baseURL, &quot;data/concatenated-cells.csv&quot;))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
</code></pre>

<pre><code class="no-highlight">## [1] 48  3
</code></pre>

<pre><code class="r"># Just show me the first few rows
head(concat.test)
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery
## 3   Dana 1,2,4,5,6                     Pierce
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard
## 5 Ramona   1,2,5,6           Snyder , Joann ,
## 6 Kelley   1,2,5,6          James , Roxanne ,
</code></pre>

<p>Notice that the data have been entered in a very silly manner. Let&#39;s split it up!</p>

<pre><code class="r"># Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes                   Siblings Likes_1 Likes_2 Likes_3
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega       1       1      NA
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery       1       1      NA
## 3   Dana 1,2,4,5,6                     Pierce       1       1      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard       1       1      NA
## 5 Ramona   1,2,5,6           Snyder , Joann ,       1       1      NA
## 6 Kelley   1,2,5,6          James , Roxanne ,       1       1      NA
##   Likes_4 Likes_5 Likes_6
## 1       1       1       1
## 2       1       1       1
## 3       1       1       1
## 4       1       1       1
## 5      NA       1       1
## 6      NA       1       1
</code></pre>

<pre><code class="r"># ... or by name, and drop the offensive first column
head(concat.split(concat.test, &quot;Likes&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega       1       1      NA       1
## 2  Rufus  Cohen , Bert , Montgomery       1       1      NA       1
## 3   Dana                     Pierce       1       1      NA       1
## 4 Carole Colon , Michelle , Ballard       1       1      NA       1
## 5 Ramona           Snyder , Joann ,       1       1      NA      NA
## 6 Kelley          James , Roxanne ,       1       1      NA      NA
##   Likes_5 Likes_6
## 1       1       1
## 2       1       1
## 3       1       1
## 4       1       1
## 5       1       1
## 6       1       1
</code></pre>

<pre><code class="r"># Retain the original values
head(concat.split(concat.test, 2, mode = &quot;value&quot;, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name                   Siblings Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega       1       2      NA       4
## 2  Rufus  Cohen , Bert , Montgomery       1       2      NA       4
## 3   Dana                     Pierce       1       2      NA       4
## 4 Carole Colon , Michelle , Ballard       1       2      NA       4
## 5 Ramona           Snyder , Joann ,       1       2      NA      NA
## 6 Kelley          James , Roxanne ,       1       2      NA      NA
##   Likes_5 Likes_6
## 1       5       6
## 2       5       6
## 3       5       6
## 4       5       6
## 5       5       6
## 6       5       6
</code></pre>

<pre><code class="r"># Let&#39;s try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col = TRUE))
</code></pre>

<pre><code class="no-highlight">##     Name     Likes Siblings_1 Siblings_2  Siblings_3
## 1   Boyd 1,2,4,5,6  Reynolds     Albert       Ortega
## 2  Rufus 1,2,4,5,6     Cohen       Bert   Montgomery
## 3   Dana 1,2,4,5,6     Pierce       &lt;NA&gt;        &lt;NA&gt;
## 4 Carole 1,2,4,5,6     Colon   Michelle      Ballard
## 5 Ramona   1,2,5,6    Snyder      Joann         &lt;NA&gt;
## 6 Kelley   1,2,5,6     James    Roxanne         &lt;NA&gt;
</code></pre>

<h2>To Do</h2>

<ul>
<li>Modify the function so that you can split multiple columns in one go?</li>
<li>Strip whitespace from string output.</li>
</ul>

<h2>References</h2>

<p>See: <a href="http://stackoverflow.com/q/10100887/1270695">http://stackoverflow.com/q/10100887/1270695</a></p>

<p>\newpage</p>

<h1>df.sorter</h1>

<h2>What it Does</h2>

<p>The <code>df.sorter</code> function allows you to sort a <code>data.frame</code> by columns or rows or both. You can also quickly subset data solums by using the <code>var.order</code> argument.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>var.order</code>: the new order in which you want the variables to appear.

<ul>
<li>Defaults to <code>names(data)</code>, which keeps the variables in the original order.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).</li>
<li>Basic subsetting can also be done using <code>var.order</code> simply by omitting the variables you want to drop.</li>
</ul></li>
<li><code>col.sort</code>: the columns <em>within</em> which there is data that need to be sorted.

<ul>
<li>Defaults to <code>NULL</code>, which means no sorting takes place.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.</li>
</ul></li>
</ul>

<blockquote>
<p>NOTE: If you are sorting both by variables and within the columns, the <code>col.sort</code> order should be based on the location of the columns in the <em>new</em> <code>data.frame</code>, not the original <code>data.frame</code>.</p>
</blockquote>

<h2>The Function</h2>

<pre><code class="r">df.sorter = function(data, var.order = names(data), col.sort = NULL) {

    if (is.numeric(var.order)) 
        var.order = colnames(data)[var.order] else var.order = var.order

    a = names(data)
    b = length(var.order)
    subs = vector(&quot;list&quot;, b)

    for (i in 1:b) {
        subs[[i]] = sort(grep(var.order[i], a, value = TRUE))
    }
    x = unlist(subs)
    y = data[, x]

    if (is.null(col.sort)) {
        y
    } else if (is.numeric(col.sort)) {
        col.sort = colnames(y)[col.sort]
        y[do.call(order, y[col.sort]), ]
    } else if (!is.numeric(col.sort)) {
        col.sort = col.sort
        y[do.call(order, y[col.sort]), ]
    }
}
</code></pre>

<h2>Examples</h2>

<pre><code class="r"># Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each = 3), times = rep(1:3, 5), measure1 = rnorm(15), 
    score1 = sample(300, 15), code1 = replicate(15, paste(sample(LETTERS[1:5], 
        3), sep = &quot;&quot;, collapse = &quot;&quot;)), measure2 = rnorm(15), score2 = sample(150:300, 
        15), code2 = replicate(15, paste(sample(LETTERS[1:5], 3), sep = &quot;&quot;, 
        collapse = &quot;&quot;)))
# Preview your data
dat
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
## 3   1     3  -0.8356    148   EBA   0.7685    222   DAE
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
## 6   2     3  -0.8205    198   EBD   0.3981    216   DCA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 9   3     3   0.5758    212   EBC  -1.1294    182   BEC
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 11  4     2   1.5118    239   EDB   1.9804    231   CAB
## 12  4     3   0.3898    188   DEB  -0.3672    160   DBE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 14  5     2  -2.2147    159   DAC   0.5697    238   BDE
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
</code></pre>

<pre><code class="r"># Change the variable order, grouping related columns Note that you do not
# need to specify full variable names, just enough that the variables can
# be uniquely identified
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;ti&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
</code></pre>

<pre><code class="no-highlight">##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># As above, but sorted by &#39;times&#39; and then &#39;id&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;), 
    col.sort = c(2, 1)))
</code></pre>

<pre><code class="no-highlight">##    id times code1 code2 measure1 measure2 score1 score2
## 1   1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 4   2     1   AED   DBA   1.5953  -0.1123     56    175
## 7   3     1   BCA   CEA   0.4874  -0.6120    234    300
## 10  4     1   BED   CDE  -0.3054   1.4330    120    234
## 13  5     1   DBA   EDB  -0.6212  -1.0441    226    154
## 2   1     2   DCB   ECD   0.1836   0.3646    180    224
</code></pre>

<pre><code class="r"># Drop &#39;measure1&#39; and &#39;measure2&#39;, sort by &#39;times&#39;, and &#39;score1&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(2, 
    3)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># As above, but using names
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), col.sort = c(&quot;times&quot;, 
    &quot;score1&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># Just sort by columns, first by &#39;times&#39; then by &#39;id&#39;
head(df.sorter(dat, col.sort = c(&quot;times&quot;, &quot;id&quot;)))
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
</code></pre>

<pre><code class="r">head(df.sorter(dat, col.sort = c(&quot;code1&quot;)))  # Sorting by character values
</code></pre>

<pre><code class="no-highlight">##    id times measure1 score1 code1 measure2 score2 code2
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add an option to sort ascending or descending&mdash;at the moment, not supported.</li>
<li>Modify the <code>grep</code> function for <code>var.order</code> to only match strings from the start of a variable name.</li>
</ul>

<p>\newpage</p>

<h1>row.extractor</h1>

<h2>What it Does</h2>

<p>The <code>row.extractor</code> function takes a <code>data.frame</code> and extracts rows with the <code>min</code>, <code>median</code>, or <code>max</code> values of a given variable, or extracts rows with specific quantiles of a given variable.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>extract.by</code>: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.</li>
<li><code>what</code>: options are <code>min</code> (for all rows matching the minimum value), <code>median</code> (for the median row or rows), <code>max</code> (for all rows matching the maximum value), or <code>all</code> (for <code>min</code>, <code>median</code>, and <code>max</code>); alternatively, a numeric vector can be specified with the desired quantiles, for instance <code>c(0, .25, .5, .75, 1)</code></li>
</ul>

<h2>The Function</h2>

<pre><code class="r">row.extractor = function(data, extract.by, what = &quot;all&quot;) {

    if (is.numeric(extract.by)) {
        extract.by = extract.by
    } else if (is.numeric(extract.by) != 0) {
        extract.by = which(colnames(data) %in% &quot;extract.by&quot;)
    }

    if (is.character(what)) {
        which.median = function(data, extract.by) {
            a = data[, extract.by]
            if (length(a)%%2 != 0) {
                which(a == median(a))
            } else if (length(a)%%2 == 0) {
                b = sort(a)[c(length(a)/2, length(a)/2 + 1)]
                c(max(which(a == b[1])), min(which(a == b[2])))
            }
        }

        X1 = data[which(data[extract.by] == min(data[extract.by])), ]  # min
        X2 = data[which(data[extract.by] == max(data[extract.by])), ]  # max
        X3 = data[which.median(data, extract.by), ]  # median

        if (identical(what, &quot;min&quot;)) {
            X1
        } else if (identical(what, &quot;max&quot;)) {
            X2
        } else if (identical(what, &quot;median&quot;)) {
            X3
        } else if (identical(what, &quot;all&quot;)) {
            rbind(X1, X3, X2)
        }
    } else if (is.numeric(what)) {
        which.quantile &lt;- function(data, extract.by, what, na.rm = FALSE) {

            x = data[, extract.by]

            if (!na.rm &amp; any(is.na(x))) 
                return(rep(NA_integer_, length(what)))

            o &lt;- order(x)
            n &lt;- sum(!is.na(x))
            o &lt;- o[seq_len(n)]

            nppm &lt;- n * what - 0.5
            j &lt;- floor(nppm)
            h &lt;- ifelse((nppm == j) &amp; ((j%%2L) == 0L), 0, 1)
            j &lt;- j + h

            j[j == 0] &lt;- 1
            o[j]
        }
        data[which.quantile(data, extract.by, what), ]  # quantile
    }
}
</code></pre>

<h2>Examples</h2>

<pre><code class="r"># Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), V3 = round(abs(rnorm(50)), 
    digits = 2), V4 = sample(1:30, 50, replace = TRUE))
# Get a sumary of the data
summary(dat)
</code></pre>

<pre><code class="no-highlight">##        V1             V2               V3              V4       
##  Min.   : 1.0   Min.   :-2.215   Min.   :0.000   Min.   : 2.00  
##  1st Qu.:13.2   1st Qu.:-0.372   1st Qu.:0.347   1st Qu.: 8.25  
##  Median :25.5   Median : 0.129   Median :0.590   Median :13.00  
##  Mean   :25.5   Mean   : 0.100   Mean   :0.774   Mean   :14.80  
##  3rd Qu.:37.8   3rd Qu.: 0.728   3rd Qu.:1.175   3rd Qu.:20.75  
##  Max.   :50.0   Max.   : 1.595   Max.   :2.400   Max.   :29.00  
</code></pre>

<pre><code class="r"># Get the rows corresponding to the &#39;min&#39;, &#39;median&#39;, and &#39;max&#39; of &#39;V4&#39;
row.extractor(dat, 4)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 28 28 -1.4708 0.00  2
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
## 11 11  1.5118 2.40 29
## 14 14 -2.2147 0.03 29
## 18 18  0.9438 1.47 29
## 19 19  0.8212 0.15 29
## 50 50  0.8811 0.47 29
</code></pre>

<pre><code class="r"># Get the &#39;min&#39; rows only, referenced by the variable name
row.extractor(dat, &quot;V4&quot;, &quot;min&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1     V2 V3 V4
## 28 28 -1.471  0  2
</code></pre>

<pre><code class="r"># Get the &#39;median&#39; rows only. Notice that there are two rows since we have
# an even number of cases and true median is the mean of the two central
# sorted values
row.extractor(dat, &quot;V4&quot;, &quot;median&quot;)
</code></pre>

<pre><code class="no-highlight">##    V1      V2   V3 V4
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
</code></pre>

<pre><code class="r"># Get the rows corresponding to the deciles of &#39;V3&#39;
row.extractor(dat, &quot;V3&quot;, seq(0.1, 1, 0.1))
</code></pre>

<pre><code class="no-highlight">##    V1       V2   V3 V4
## 10 10 -0.30539 0.14 22
## 26 26 -0.05613 0.29 16
## 39 39  1.10003 0.37 13
## 41 41 -0.16452 0.54 10
## 30 30  0.41794 0.59 26
## 44 44  0.55666 0.70  5
## 37 37 -0.39429 1.06 21
## 49 49 -0.11235 1.22 14
## 34 34 -0.05381 1.52 19
## 11 11  1.51178 2.40 29
</code></pre>

<h2>References</h2>

<p><code>which.quantile</code> function by <a href="http://stackoverflow.com/users/755257/cbeleites">cbeleites</a><br/><br/>
See: <a href="http://stackoverflow.com/q/10256503/1270695">http://stackoverflow.com/q/10256503/1270695</a></p>

</body>

</html>

