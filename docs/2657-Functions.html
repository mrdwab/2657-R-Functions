<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>concat.split</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<p>% 2657 Functions<br/>
% Ananda Mahto</p>

<p>\pagenumbering{gobble}</p>

<p>\pagestyle{plain}<br/>
\tableofcontents<br/>
\cleardoublepage</p>

<p>\pagestyle{headings}<br/>
\setcounter{page}{1}<br/>
\pagenumbering{arabic}</p>

<p>\part{Function Descriptions and Examples}</p>

<h1>concat.split</h1>

<p>The <code>concat.split</code> function takes a column with multiple values, splits the values into a list or into separate columns, and returns a new <code>data.frame</code>.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>split.col</code>: the variable that needs to be split; can be specified either by the column number or the variable name.</li>
<li><code>to.list</code>: logical; should the split column be returned as a single variable list (named &ldquo;original-variable_list&rdquo;) or multiple new variables? If <code>to.list</code> is <code>TRUE</code>, the <code>mode</code> argument is ignored and a list of the original values are returned.</li>
<li><code>mode</code>: can be either <code>binary</code> or <code>value</code> (where <code>binary</code> is default and it recodes values to <code>1</code> or <code>NA</code>, like Boolean, but without assuming <code>0</code> when data is not available).</li>
<li><code>sep</code>: the character separating each value (defaults to <code>&quot;,&quot;</code>).</li>
<li><code>drop.col</code>: logical (whether to remove the original variable from the output or not; defaults to <code>TRUE</code>).</li>
</ul>

<h2>Examples</h2>

<p>First load some data from a CSV stored at <a href="http://github.com">github</a>. The URL is an HTTPS, so we need to use <code>getURL</code> from <code>RCurl</code>.</p>

<pre><code class="r">require(RCurl)
</code></pre>

<pre><code>## Loading required package: RCurl
</code></pre>

<pre><code>## Loading required package: bitops
</code></pre>

<pre><code class="r">baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
temp = getURL(paste0(baseURL, &quot;data/concatenated-cells.csv&quot;))
concat.test = read.csv(textConnection(temp))
rm(temp)

# How big is the dataset?
dim(concat.test)
</code></pre>

<pre><code>## [1] 48  4
</code></pre>

<pre><code class="r"># Just show me the first few rows
head(concat.test)
</code></pre>

<pre><code>##     Name     Likes                   Siblings    Hates
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;
## 3   Dana 1,2,4,5,6                     Pierce       2;
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;
</code></pre>

<p>Notice that the data have been entered in a very silly manner. Let&#39;s split it up!</p>

<pre><code class="r"># Load the function!
# require(RCurl)
# baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/concat.split.R&quot;))))

# Split up the second column, selecting by column number
head(concat.split(concat.test, 2))
</code></pre>

<pre><code>##     Name     Likes                   Siblings    Hates Likes_1 Likes_2 Likes_3
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4;       1       1      NA
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4;       1       1      NA
## 3   Dana 1,2,4,5,6                     Pierce       2;       1       1      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4;       1       1      NA
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;       1       1      NA
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;       1       1      NA
##   Likes_4 Likes_5 Likes_6
## 1       1       1       1
## 2       1       1       1
## 3       1       1       1
## 4       1       1       1
## 5      NA       1       1
## 6      NA       1       1
</code></pre>

<pre><code class="r"># ... or by name, and drop the offensive first column
head(concat.split(concat.test, &quot;Likes&quot;, drop.col=TRUE))
</code></pre>

<pre><code>##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       1      NA       1
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       1      NA       1
## 3   Dana                     Pierce       2;       1       1      NA       1
## 4 Carole Colon , Michelle , Ballard     1;4;       1       1      NA       1
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       1      NA      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       1      NA      NA
##   Likes_5 Likes_6
## 1       1       1
## 2       1       1
## 3       1       1
## 4       1       1
## 5       1       1
## 6       1       1
</code></pre>

<pre><code class="r"># The &quot;Hates&quot; column uses a different separator:
head(concat.split(concat.test, &quot;Hates&quot;, sep=&quot;;&quot;, drop.col=TRUE))
</code></pre>

<pre><code>##     Name     Likes                   Siblings Hates_1 Hates_2 Hates_3 Hates_4
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega      NA       1      NA       1
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery       1       1       1       1
## 3   Dana 1,2,4,5,6                     Pierce      NA       1      NA      NA
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard       1      NA      NA       1
## 5 Ramona   1,2,5,6           Snyder , Joann ,       1       1       1      NA
## 6 Kelley   1,2,5,6          James , Roxanne ,       1      NA      NA       1
</code></pre>

<pre><code class="r"># Retain the original values
head(concat.split(concat.test, 2, mode=&quot;value&quot;, drop.col=TRUE))
</code></pre>

<pre><code>##     Name                   Siblings    Hates Likes_1 Likes_2 Likes_3 Likes_4
## 1   Boyd Reynolds , Albert , Ortega     2;4;       1       2      NA       4
## 2  Rufus  Cohen , Bert , Montgomery 1;2;3;4;       1       2      NA       4
## 3   Dana                     Pierce       2;       1       2      NA       4
## 4 Carole Colon , Michelle , Ballard     1;4;       1       2      NA       4
## 5 Ramona           Snyder , Joann ,   1;2;3;       1       2      NA      NA
## 6 Kelley          James , Roxanne ,     1;4;       1       2      NA      NA
##   Likes_5 Likes_6
## 1       5       6
## 2       5       6
## 3       5       6
## 4       5       6
## 5       5       6
## 6       5       6
</code></pre>

<pre><code class="r"># Let&#39;s try splitting some strings... Same syntax
head(concat.split(concat.test, 3, drop.col=TRUE))
</code></pre>

<pre><code>##     Name     Likes    Hates Siblings_1 Siblings_2 Siblings_3
## 1   Boyd 1,2,4,5,6     2;4;   Reynolds     Albert     Ortega
## 2  Rufus 1,2,4,5,6 1;2;3;4;      Cohen       Bert Montgomery
## 3   Dana 1,2,4,5,6       2;     Pierce       &lt;NA&gt;       &lt;NA&gt;
## 4 Carole 1,2,4,5,6     1;4;      Colon   Michelle    Ballard
## 5 Ramona   1,2,5,6   1;2;3;     Snyder      Joann       &lt;NA&gt;
## 6 Kelley   1,2,5,6     1;4;      James    Roxanne       &lt;NA&gt;
</code></pre>

<pre><code class="r"># Split up the &quot;Likes column&quot; into a list variable; retain original column
head(concat.split(concat.test, 2, to.list=TRUE, drop.col=FALSE))
</code></pre>

<pre><code>##     Name     Likes                   Siblings    Hates    Likes_list
## 1   Boyd 1,2,4,5,6 Reynolds , Albert , Ortega     2;4; 1, 2, 4, 5, 6
## 2  Rufus 1,2,4,5,6  Cohen , Bert , Montgomery 1;2;3;4; 1, 2, 4, 5, 6
## 3   Dana 1,2,4,5,6                     Pierce       2; 1, 2, 4, 5, 6
## 4 Carole 1,2,4,5,6 Colon , Michelle , Ballard     1;4; 1, 2, 4, 5, 6
## 5 Ramona   1,2,5,6           Snyder , Joann ,   1;2;3;    1, 2, 5, 6
## 6 Kelley   1,2,5,6          James , Roxanne ,     1;4;    1, 2, 5, 6
</code></pre>

<pre><code class="r"># View the structure of the output for the first 10 rows to verify 
# that the new column is a list; note the difference between &quot;Likes&quot;
# and &quot;Likes_list&quot;.
str(concat.split(concat.test, 2, to.list=TRUE, drop.col=FALSE)[1:10, c(2, 5)])
</code></pre>

<pre><code>## &#39;data.frame&#39;:    10 obs. of  2 variables:
##  $ Likes     : Factor w/ 5 levels &quot;1,2,3,4,5&quot;,&quot;1,2,4,5&quot;,..: 3 3 3 3 5 5 3 3 3 4
##  $ Likes_list:List of 10
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 5 6
##   ..$ : num  1 2 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 4 5 6
##   ..$ : num  1 2 5
</code></pre>

<h2>Advanced Usage</h2>

<p>It is also possible to use <code>concat.split</code> to split multiple columns at once. This can be done in stages, or it can be all wrapped in nested statements, as follows:</p>

<pre><code class="r">do.call(cbind, c(concat.test[1],
                 lapply(lapply(2:ncol(concat.test),
                               function(x) concat.test[x]),
                        concat.split, split.col=1, drop=TRUE, sep=&quot;;|,&quot;)))
</code></pre>

<p>In the example above (working from the inside of the function outwards):</p>

<ul>
<li>First, <code>lapply(2:ncol(concat.test), ...)</code> splits the columns of the <code>data.frame</code> into a list. </li>
<li>Second, <code>lapply(lapply(...))</code> does the splitting work.

<ul>
<li>Note the use of <code>sep=&quot;;|,&quot;</code> to match multiple separators on which to split; if further separators are required, they can be specified by using the pipe symbol (<code>|</code>) <em>with no leading or trailing spaces</em>.</li>
</ul></li>
<li>Finally, <code>do.call(cbind, ...)</code> is evaluated last, &ldquo;binding&rdquo; the data together by columns. In this case, the data being bound together is the first column from the <code>concat.test</code> dataset, and the splitted output of the remaining columns. </li>
</ul>

<p>Alternatively, a similar approach can be taken using the function <code>dfcols.list</code> (see the &ldquo;Snippets and Tips&rdquo; section of this manual for the <code>dfcols.list</code> function).</p>

<pre><code class="r"># Show just the first few lines, Boolean mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, sep=&quot;;|,&quot;))))
</code></pre>

<pre><code>##     Name Likes_1 Likes_2 Likes_3 Likes_4 Likes_5 Likes_6 Siblings_1 Siblings_2
## 1   Boyd       1       1      NA       1       1       1   Reynolds     Albert
## 2  Rufus       1       1      NA       1       1       1      Cohen       Bert
## 3   Dana       1       1      NA       1       1       1     Pierce       &lt;NA&gt;
## 4 Carole       1       1      NA       1       1       1      Colon   Michelle
## 5 Ramona       1       1      NA      NA       1       1     Snyder      Joann
## 6 Kelley       1       1      NA      NA       1       1      James    Roxanne
##   Siblings_3 Hates_1 Hates_2 Hates_3 Hates_4
## 1     Ortega      NA       1      NA       1
## 2 Montgomery       1       1       1       1
## 3       &lt;NA&gt;      NA       1      NA      NA
## 4    Ballard       1      NA      NA       1
## 5       &lt;NA&gt;       1       1       1      NA
## 6       &lt;NA&gt;       1      NA      NA       1
</code></pre>

<pre><code class="r"># Show just the first few lines, value mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, 
                             sep=&quot;;|,&quot;, mode=&quot;value&quot;))))
</code></pre>

<pre><code>##     Name Likes_1 Likes_2 Likes_3 Likes_4 Likes_5 Likes_6 Siblings_1 Siblings_2
## 1   Boyd       1       2      NA       4       5       6   Reynolds     Albert
## 2  Rufus       1       2      NA       4       5       6      Cohen       Bert
## 3   Dana       1       2      NA       4       5       6     Pierce       &lt;NA&gt;
## 4 Carole       1       2      NA       4       5       6      Colon   Michelle
## 5 Ramona       1       2      NA      NA       5       6     Snyder      Joann
## 6 Kelley       1       2      NA      NA       5       6      James    Roxanne
##   Siblings_3 Hates_1 Hates_2 Hates_3 Hates_4
## 1     Ortega      NA       2      NA       4
## 2 Montgomery       1       2       3       4
## 3       &lt;NA&gt;      NA       2      NA      NA
## 4    Ballard       1      NA      NA       4
## 5       &lt;NA&gt;       1       2       3      NA
## 6       &lt;NA&gt;       1      NA      NA       4
</code></pre>

<pre><code class="r"># Show just the first few lines, list output mode
head(do.call(cbind, c(concat.test[1],
                      lapply(dfcols.list(concat.test[-1]),
                             concat.split, split.col=1, drop=TRUE, 
                             sep=&quot;;|,&quot;, to.list=TRUE))))
</code></pre>

<pre><code>##     Name    Likes_list            Siblings_list Hates_list
## 1   Boyd 1, 2, 4, 5, 6 Reynolds, Albert, Ortega       2, 4
## 2  Rufus 1, 2, 4, 5, 6  Cohen, Bert, Montgomery 1, 2, 3, 4
## 3   Dana 1, 2, 4, 5, 6                   Pierce          2
## 4 Carole 1, 2, 4, 5, 6 Colon, Michelle, Ballard       1, 4
## 5 Ramona    1, 2, 5, 6            Snyder, Joann    1, 2, 3
## 6 Kelley    1, 2, 5, 6           James, Roxanne       1, 4
</code></pre>

<h2>References</h2>

<p>See: <a href="http://stackoverflow.com/q/10100887/1270695">http://stackoverflow.com/q/10100887/1270695</a></p>

<p>\newpage</p>

<h1>df.sorter</h1>

<p>The <code>df.sorter</code> function allows you to sort a <code>data.frame</code> by columns or rows or both. You can also quickly subset data columns by using the <code>var.order</code> argument.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>var.order</code>: the new order in which you want the variables to appear.

<ul>
<li>Defaults to <code>names(data)</code>, which keeps the variables in the original order.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable name; partial name matching also works, but requires that the partial match identifies similar columns uniquely (see examples).</li>
<li>Basic subsetting can also be done using <code>var.order</code> simply by omitting the variables you want to drop.</li>
</ul></li>
<li><code>col.sort</code>: the columns <em>within</em> which there is data that need to be sorted.

<ul>
<li>Defaults to <code>NULL</code>, which means no sorting takes place.</li>
<li>Variables can be referred to either by a vector of their index numbers or by a vector of the variable names; full names must be provided.</li>
</ul></li>
<li><code>at.start</code>: Should the pattern matching be from the start of the variable name? Defaults to &ldquo;TRUE&rdquo;.</li>
</ul>

<blockquote>
<p>NOTE: If you are sorting both by variables and within the columns, the <code>col.sort</code> order should be based on the location of the columns in the <em>new</em> <code>data.frame</code>, not the original <code>data.frame</code>.</p>
</blockquote>

<h2>Examples</h2>

<pre><code class="r"># Load the function!
# require(RCurl)
# baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/df.sorter.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(id = rep(1:5, each=3), times = rep(1:3, 5),
                 measure1 = rnorm(15), score1 = sample(300, 15),
                 code1 = replicate(15, paste(sample(LETTERS[1:5], 3), 
                                             sep=&quot;&quot;, collapse=&quot;&quot;)),
                 measure2 = rnorm(15), score2 = sample(150:300, 15), 
                 code2 = replicate(15, paste(sample(LETTERS[1:5], 3), 
                                             sep=&quot;&quot;, collapse=&quot;&quot;)))
# Preview your data
dat
</code></pre>

<pre><code>##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
## 3   1     3  -0.8356    148   EBA   0.7685    222   DAE
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
## 6   2     3  -0.8205    198   EBD   0.3981    216   DCA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 9   3     3   0.5758    212   EBC  -1.1294    182   BEC
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 11  4     2   1.5118    239   EDB   1.9804    231   CAB
## 12  4     3   0.3898    188   DEB  -0.3672    160   DBE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 14  5     2  -2.2147    159   DAC   0.5697    238   BDE
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
</code></pre>

<pre><code class="r"># Change the variable order, grouping related columns
# Note that you do not need to specify full variable names,
#    just enough that the variables can be uniquely identified
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;ti&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;)))
</code></pre>

<pre><code>##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># Same output, but with a more awkward syntax
head(df.sorter(dat, var.order = c(1, 2, 5, 8, 3, 6, 4, 7)))
</code></pre>

<pre><code>##   id times code1 code2 measure1 measure2 score1 score2
## 1  1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 2  1     2   DCB   ECD   0.1836   0.3646    180    224
## 3  1     3   EBA   DAE  -0.8356   0.7685    148    222
## 4  2     1   AED   DBA   1.5953  -0.1123     56    175
## 5  2     2   CEB   DAC   0.3295   0.8811    245    260
## 6  2     3   EBD   DCA  -0.8205   0.3981    198    216
</code></pre>

<pre><code class="r"># As above, but sorted by &#39;times&#39; and then &#39;id&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;cod&quot;, &quot;mea&quot;, &quot;sco&quot;), 
               col.sort = c(2, 1)))
</code></pre>

<pre><code>##    id times code1 code2 measure1 measure2 score1 score2
## 1   1     1   DAB   CEB  -0.6265  -0.7075    145    299
## 4   2     1   AED   DBA   1.5953  -0.1123     56    175
## 7   3     1   BCA   CEA   0.4874  -0.6120    234    300
## 10  4     1   BED   CDE  -0.3054   1.4330    120    234
## 13  5     1   DBA   EDB  -0.6212  -1.0441    226    154
## 2   1     2   DCB   ECD   0.1836   0.3646    180    224
</code></pre>

<pre><code class="r"># Drop &#39;measure1&#39; and &#39;measure2&#39;, sort by &#39;times&#39;, and &#39;score1&#39;
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), 
               col.sort = c(2, 3)))
</code></pre>

<pre><code>##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># As above, but using names
head(df.sorter(dat, var.order = c(&quot;id&quot;, &quot;tim&quot;, &quot;sco&quot;, &quot;cod&quot;), 
               col.sort = c(&quot;times&quot;, &quot;score1&quot;)))
</code></pre>

<pre><code>##    id times score1 score2 code1 code2
## 4   2     1     56    175   AED   DBA
## 10  4     1    120    234   BED   CDE
## 1   1     1    145    299   DAB   CEB
## 13  5     1    226    154   DBA   EDB
## 7   3     1    234    300   BCA   CEA
## 8   3     2     32    179   CDA   CAD
</code></pre>

<pre><code class="r"># Just sort by columns, first by &#39;times&#39; then by &#39;id&#39;
head(df.sorter(dat, col.sort = c(&quot;times&quot;, &quot;id&quot;)))
</code></pre>

<pre><code>##    id times measure1 score1 code1 measure2 score2 code2
## 1   1     1  -0.6265    145   DAB  -0.7075    299   CEB
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 13  5     1  -0.6212    226   DBA  -1.0441    154   EDB
## 2   1     2   0.1836    180   DCB   0.3646    224   ECD
</code></pre>

<pre><code class="r">head(df.sorter(dat, col.sort = c(&quot;code1&quot;))) # Sorting by character values
</code></pre>

<pre><code>##    id times measure1 score1 code1 measure2 score2 code2
## 4   2     1   1.5953     56   AED  -0.1123    175   DBA
## 15  5     3   1.1249    152   AED  -0.1351    277   DCE
## 7   3     1   0.4874    234   BCA  -0.6120    300   CEA
## 10  4     1  -0.3054    120   BED   1.4330    234   CDE
## 8   3     2   0.7383     32   CDA   0.3411    179   CAD
## 5   2     2   0.3295    245   CEB   0.8811    260   DAC
</code></pre>

<pre><code class="r"># Pattern matching anywhere in the variable name
head(df.sorter(dat, var.order= &quot;co&quot;, at.start=FALSE))
</code></pre>

<pre><code>##   code1 code2 score1 score2
## 1   DAB   CEB    145    299
## 2   DCB   ECD    180    224
## 3   EBA   DAE    148    222
## 4   AED   DBA     56    175
## 5   CEB   DAC    245    260
## 6   EBD   DCA    198    216
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add an option to sort ascending or descending&mdash;at the moment, not supported.</li>
</ul>

<p>\newpage</p>

<h1>multi.freq.table</h1>

<p>The <code>multi.freq.table</code> function takes a data frame containing Boolean responses to multiple response questions and tabulates the number of responses by the possible combinations of answers. In addition to tabulating the frequency (<code>Freq</code>), there are two other columns in the output: <em>Percent of Responses</em> (<code>Pct.of.Resp</code>) and <em>Percent of Cases</em> (<code>Pct.of.Cases</code>). <em>Percent of Responses</em> is the frequency divided by the total number of answers provided; this column should sum to 100%. In some cases, for instance when a combination table is generated and there are cases where a respondent did not select any option, the <em>Percent of Responses</em> value would be more than 100%. <em>Percent of Cases</em> is the frequency divided by the total number of valid cases; this column would most likely sum to more than 100% when a basic table is produced since each respondent (case) can select multiple answers, but should sum to 100% with other tables.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: The multiple responses that need to be tabulated.</li>
<li><code>sep</code>: The desired separator for collapsing the combinations of options; defaults to <code>&quot;&quot;</code> (collapsing with no space between each option name).</li>
<li><code>boolean</code>: Are you tabulating boolean data (see <code>dat</code> examples)? Defaults to <code>TRUE</code>.</li>
<li><code>factors</code>: If you are trying to tabulate non-boolean data, and the data are not factors, you can specify the factors here (see <code>dat2</code> examples). 

<ul>
<li>Defaults to <code>NULL</code> and is not used when <code>boolean = TRUE</code>.</li>
</ul></li>
<li><code>NAto0</code>: Should <code>NA</code> values be converted to <code>0</code>.

<ul>
<li>Defaults to <code>TRUE</code>, in which case, the number of valid cases should be the same as the number of cases overall.</li>
<li>If set to <code>FALSE</code>, any rows with <code>NA</code> values will be dropped as invalid cases.</li>
<li>Only applies when <code>boolean = TRUE</code>.</li>
</ul></li>
<li><code>basic</code>: Should a basic table of each item, rather than combinations of items, be created? Defaults to <code>FALSE</code>.</li>
<li><code>dropzero</code>: Should combinations with a frequency of zero be dropped from the final table? 

<ul>
<li>Defaults to <code>TRUE</code>.</li>
<li>Does not apply when <code>boolean = TRUE</code>.</li>
</ul></li>
<li><code>clean</code>: Should the original tabulated data be retained or dropped from the final table? 

<ul>
<li>Defaults to <code>TRUE</code>.</li>
<li>Does not apply when <code>boolean = TRUE</code>.</li>
</ul></li>
</ul>

<h2>Examples</h2>

<h3>Boolean Data</h3>

<pre><code class="r"># Load the function!
# require(RCurl)
# baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/multi.freq.table.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(A = sample(c(0, 1), 20, replace=TRUE),
                 B = sample(c(0, 1, NA), 20, 
                            prob=c(.3, .6, .1), replace=TRUE),
                 C = sample(c(0, 1, NA), 20, 
                            prob=c(.7, .2, .1), replace=TRUE),
                 D = sample(c(0, 1, NA), 20, 
                            prob=c(.3, .6, .1), replace=TRUE),
                 E = sample(c(0, 1, NA), 20, 
                            prob=c(.4, .4, .2), replace=TRUE))
# View your data
dat
</code></pre>

<pre><code>##    A  B C  D  E
## 1  0 NA 1 NA  0
## 2  0  1 0  1  0
## 3  1  0 1  1  1
## 4  1  1 0  1  1
## 5  0  1 0  0  0
## 6  1  1 1  1  1
## 7  1  1 0  1  0
## 8  1  1 0  0  1
## 9  1  0 1  1  1
## 10 0  1 0  0  1
## 11 0  1 0  1  1
## 12 0  1 1  0  1
## 13 1  1 0  1  0
## 14 0  1 0  1 NA
## 15 1  0 0  1  0
## 16 0  0 0  0  0
## 17 1  0 0  0  0
## 18 1  1 0  1  0
## 19 0  0 0  0 NA
## 20 1  1 0 NA  0
</code></pre>

<pre><code class="r"># How many cases have &quot;NA&quot; values?
table(is.na(rowSums(dat)))
</code></pre>

<pre><code>## 
## FALSE  TRUE 
##    16     4 
</code></pre>

<pre><code class="r"># Apply the function with all defaults accepted
multi.freq.table(dat)
</code></pre>

<pre><code>## Total cases: 20 Valid cases: 20 Total responses: 48 Valid responses: 48
</code></pre>

<pre><code>##    Combn Freq Weighted.Freq Pct.of.Resp Pct.of.Cases
## 1           2             2       4.167           10
## 2      A    1             1       2.083            5
## 3      B    1             1       2.083            5
## 4     AB    1             2       4.167            5
## 5      C    1             1       2.083            5
## 6     AD    1             2       4.167            5
## 7     BD    2             4       8.333           10
## 8    ABD    3             9      18.750           15
## 9     BE    1             2       4.167            5
## 10   ABE    1             3       6.250            5
## 11   BCE    1             3       6.250            5
## 12   BDE    1             3       6.250            5
## 13  ABDE    1             4       8.333            5
## 14  ACDE    2             8      16.667           10
## 15 ABCDE    1             5      10.417            5
</code></pre>

<pre><code class="r"># Tabulate only on variables &quot;A&quot;, &quot;B&quot;, and &quot;D&quot;, with a different
# separator, keep any zero frequency values, and keeping the 
# original tabulations. There are no solitary &quot;D&quot; responses.
multi.freq.table(dat[c(1, 2, 4)], sep=&quot;-&quot;, dropzero=FALSE, clean=FALSE)
</code></pre>

<pre><code>## Total cases: 20 Valid cases: 20 Total responses: 35 Valid responses: 35
</code></pre>

<pre><code>##   A B D Freq Combn Weighted.Freq Pct.of.Resp Pct.of.Cases
## 1 0 0 0    3                   3       8.571           15
## 2 1 0 0    1     A             1       2.857            5
## 3 0 1 0    3     B             3       8.571           15
## 4 1 1 0    2   A-B             4      11.429           10
## 5 0 0 1    0     D             0       0.000            0
## 6 1 0 1    3   A-D             6      17.143           15
## 7 0 1 1    3   B-D             6      17.143           15
## 8 1 1 1    5 A-B-D            15      42.857           25
</code></pre>

<pre><code class="r"># As above, but without converting &quot;NA&quot; to &quot;0&quot;.
# Note the difference in the number of valid cases.
multi.freq.table(dat[c(1, 2, 4)], NAto0=FALSE, 
                 sep=&quot;-&quot;, dropzero=FALSE, clean=FALSE)
</code></pre>

<pre><code>## Total cases: 20 Valid cases: 18 Total responses: 35 Valid responses: 33
</code></pre>

<pre><code>##   A B D Freq Combn Weighted.Freq Pct.of.Resp Pct.of.Cases
## 1 0 0 0    2                   2       6.061       11.111
## 2 1 0 0    1     A             1       3.030        5.556
## 3 0 1 0    3     B             3       9.091       16.667
## 4 1 1 0    1   A-B             2       6.061        5.556
## 5 0 0 1    0     D             0       0.000        0.000
## 6 1 0 1    3   A-D             6      18.182       16.667
## 7 0 1 1    3   B-D             6      18.182       16.667
## 8 1 1 1    5 A-B-D            15      45.455       27.778
</code></pre>

<pre><code class="r"># View a basic table.
multi.freq.table(dat, basic=TRUE)
</code></pre>

<pre><code>## Total cases: 20 Valid cases: 20 Total responses: 48 Valid responses: 48
</code></pre>

<pre><code>##   Freq Pct.of.Resp Pct.of.Cases
## A   11       22.92           55
## B   13       27.08           65
## C    5       10.42           25
## D   11       22.92           55
## E    8       16.67           40
</code></pre>

<h3>Non-Boolean Data</h3>

<pre><code class="r"># Make up some data
dat2 = structure(list(Reason.1 = c(&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;, 
                                   &quot;three&quot;, &quot;one&quot;, &quot;one&quot;, NA, &quot;two&quot;), 
                      Reason.2 = c(&quot;two&quot;, &quot;three&quot;, &quot;three&quot;, NA, NA, 
                                   &quot;two&quot;, &quot;three&quot;, &quot;two&quot;, NA, NA), 
                      Reason.3 = c(&quot;three&quot;, NA, NA, NA, NA, 
                                   NA, NA, &quot;three&quot;, NA, NA)), 
                 .Names = c(&quot;Reason.1&quot;, &quot;Reason.2&quot;, &quot;Reason.3&quot;), 
                 class = &quot;data.frame&quot;, 
                 row.names = c(NA, -10L))
# View your data
dat2
</code></pre>

<pre><code>##    Reason.1 Reason.2 Reason.3
## 1       one      two    three
## 2       one    three     &lt;NA&gt;
## 3       two    three     &lt;NA&gt;
## 4       one     &lt;NA&gt;     &lt;NA&gt;
## 5       two     &lt;NA&gt;     &lt;NA&gt;
## 6     three      two     &lt;NA&gt;
## 7       one    three     &lt;NA&gt;
## 8       one      two    three
## 9      &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;
## 10      two     &lt;NA&gt;     &lt;NA&gt;
</code></pre>

<pre><code class="r"># The following will not work.
# The data are not factored.
multi.freq.table(dat2, boolean=FALSE)
</code></pre>

<pre><code>## Error: Input variables must be factors.  Please provide factors using the
## &#39;factors&#39; argument or convert your data to factor before using function.
</code></pre>

<pre><code class="r"># Factor create the factors.
multi.freq.table(dat2, boolean=FALSE, 
                 factors = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;))
</code></pre>

<pre><code>## Total cases: 10 Total responses: 17
</code></pre>

<pre><code>##         Combos Freq Weighted.Freq Pct.of.Resp Pct.of.Cases
## 1                 1             1       5.882           10
## 8          one    1             1       5.882           10
## 12         two    2             2      11.765           20
## 15    onethree    2             4      23.529           20
## 17    threetwo    2             4      23.529           20
## 22 onethreetwo    2             6      35.294           20
</code></pre>

<pre><code class="r"># And, a basic table.
multi.freq.table(dat2, boolean=FALSE,
                 factors = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;),
                 basic=TRUE)
</code></pre>

<pre><code>## Total cases: 10 Total responses: 17
</code></pre>

<pre><code>##    Item Freq Pct.of.Resp Pct.of.Cases
## 1   one    5       29.41           50
## 2   two    6       35.29           60
## 3 three    6       35.29           60
</code></pre>

<h3>Extended Examples</h3>

<p>The following example is based on some data available from the University of Auckland&#39;s Student Learning Resources<sup>[See:</sup> <a href="http://www.cad.auckland.ac.nz/index.php?p=spss">http://www.cad.auckland.ac.nz/index.php?p=spss</a>].</p>

<p>When the data are read into R, the factor labels are very long, which makes it difficult to see on the screen. Thus, in the first example that follows, the factor levels are first recoded before the multiple frequency tables are created. Additionally, the data for the binary information in the second example was coded in a common <code>1 = Yes</code> and <code>2 = No</code> format, but we need <code>0 = No</code> instead, so we need to do some recoding there too before using the function.</p>

<pre><code class="r"># Get the data
library(foreign)
temp = &quot;http://cad.auckland.ac.nz/file.php/content/files/slc/&quot;
computer = read.spss(paste0(temp, 
                            &quot;computer_multiple_response.sav&quot;), 
                     to.data.frame=TRUE)
rm(temp)
# Preview 
dim(computer)
</code></pre>

<pre><code>## [1] 100  20
</code></pre>

<pre><code class="r">names(computer)
</code></pre>

<pre><code>##  [1] &quot;id&quot;       &quot;ms_word&quot;  &quot;ms_excel&quot; &quot;ms_ppt&quot;   &quot;ms_outlk&quot; &quot;ms_pub&quot;  
##  [7] &quot;ms_proj&quot;  &quot;ms_acc&quot;   &quot;netscape&quot; &quot;int_expl&quot; &quot;adobe_rd&quot; &quot;endnote&quot; 
## [13] &quot;spss&quot;     &quot;quality1&quot; &quot;quality2&quot; &quot;quality3&quot; &quot;quality4&quot; &quot;quality5&quot;
## [19] &quot;quality6&quot; &quot;gender&quot;  
</code></pre>

<pre><code class="r"># First, let&#39;s just tabulate the instructor qualities.
#   Extract the relevant columns, and relevel the factors.
instructor.quality = 
  computer[, grep(&quot;quali&quot;, names(computer))]
# View the existing levels.
lapply(instructor.quality, levels)[[1]]
</code></pre>

<pre><code>## [1] &quot;Ability to provide practical examples&quot; 
## [2] &quot;Ability to answer questions positively&quot;
## [3] &quot;Ability to clearly explain concepts&quot;   
## [4] &quot;Ability to instruct at a suitable pace&quot;
## [5] &quot;Knowledge of software&quot;                 
## [6] &quot;Humour&quot;                                
## [7] &quot;Other&quot;                                 
</code></pre>

<pre><code class="r">instructor.quality = lapply(instructor.quality,
                            function(x) { levels(x) = 
  list(Q1 = &quot;Ability to provide practical examples&quot;,
       Q2 = &quot;Ability to answer questions positively&quot;,
       Q3 = &quot;Ability to clearly explain concepts&quot;,
       Q4 = &quot;Ability to instruct at a suitable pace&quot;,
       Q5 = &quot;Knowledge of Software&quot;,
       Q6 = &quot;Humour&quot;, Q7 = &quot;Other&quot;); x })
# Now, apply multi.freq.table to the data.
multi.freq.table(data.frame(instructor.quality),
                 boolean=FALSE, basic=TRUE)
</code></pre>

<pre><code>## Total cases: 100 Total responses: 260
</code></pre>

<pre><code>##   Item Freq Pct.of.Resp Pct.of.Cases
## 1   Q1   47      18.077           47
## 2   Q2   59      22.692           59
## 3   Q3   55      21.154           55
## 4   Q4   43      16.538           43
## 5   Q5    0       0.000            0
## 6   Q6   47      18.077           47
## 7   Q7    9       3.462            9
</code></pre>

<pre><code class="r">list(head(multi.freq.table(data.frame(instructor.quality),
                           boolean=FALSE, sep=&quot;-&quot;)),
     tail(multi.freq.table(data.frame(instructor.quality),
                           boolean=FALSE, sep=&quot;-&quot;)))
</code></pre>

<pre><code>## Total cases: 100 Total responses: 260
</code></pre>

<pre><code>## Total cases: 100 Total responses: 260
</code></pre>

<pre><code>## [[1]]
##    Combos Freq Weighted.Freq Pct.of.Resp Pct.of.Cases
## 1      Q1    1             1      0.3846            1
## 21     Q2    3             3      1.1538            3
## 31     Q3    2             2      0.7692            2
## 37     Q4    2             2      0.7692            2
## 39     Q6    3             3      1.1538            3
## 41  Q1-Q2    8            16      6.1538            8
## 
## [[2]]
##                Combos Freq Weighted.Freq Pct.of.Resp Pct.of.Cases
## 133       Q1-Q3-Q6-Q7    1             4       1.538            1
## 141       Q2-Q3-Q4-Q6    4            16       6.154            4
## 151       Q3-Q4-Q6-Q7    1             4       1.538            1
## 161    Q1-Q2-Q3-Q4-Q6    1             5       1.923            1
## 164    Q1-Q2-Q3-Q6-Q7    1             5       1.923            1
## 201 Q1-Q2-Q3-Q4-Q6-Q7    1             6       2.308            1
## 
</code></pre>

<pre><code class="r"># Now. let&#39;s look at the software.
instructors.sw = computer[2:13]
# These columns are coded as 1 = Yes and 2 = No,
#   so, convert to integers, and subtract two, and
#   take the absolute value to convert to binary.
instructors.sw = lapply(instructors.sw, 
                        function(x) abs(as.integer(x)-2))
# Apply multi.freq.table
multi.freq.table(data.frame(instructors.sw), basic=TRUE)
</code></pre>

<pre><code>## Total cases: 100 Valid cases: 100 Total responses: 551 Valid responses: 551
</code></pre>

<pre><code>##          Freq Pct.of.Resp Pct.of.Cases
## ms_word    77      13.975           77
## ms_excel   48       8.711           48
## ms_ppt     55       9.982           55
## ms_outlk   52       9.437           52
## ms_pub     19       3.448           19
## ms_proj    21       3.811           21
## ms_acc     57      10.345           57
## netscape   10       1.815           10
## int_expl   84      15.245           84
## adobe_rd   48       8.711           48
## endnote    55       9.982           55
## spss       25       4.537           25
</code></pre>

<pre><code class="r"># The output here is not pretty. To get prettier (or more meaningful)
#   output, provide shorter names for the variables or use just a
#   meaningful subset of the variables.
list(head(multi.freq.table(data.frame(instructors.sw), sep=&quot;-&quot;)),
     tail(multi.freq.table(data.frame(instructors.sw), sep=&quot;-&quot;)))
</code></pre>

<pre><code>## Total cases: 100 Valid cases: 100 Total responses: 551 Valid responses: 551
</code></pre>

<pre><code>## Total cases: 100 Valid cases: 100 Total responses: 551 Valid responses: 551
</code></pre>

<pre><code>## [[1]]
##                                            Combn Freq Weighted.Freq Pct.of.Resp
## 1                 ms_word-ms_excel-ms_ppt-ms_acc    1             4      0.7260
## 2 ms_word-ms_excel-ms_ppt-ms_outlk-ms_pub-ms_acc    1             6      1.0889
## 3                                       int_expl    2             2      0.3630
## 4                               ms_word-int_expl    1             2      0.3630
## 5                        ms_word-ms_ppt-int_expl    1             3      0.5445
## 6                      ms_word-ms_outlk-int_expl    1             3      0.5445
##   Pct.of.Cases
## 1            1
## 2            1
## 3            2
## 4            1
## 5            1
## 6            1
## 
## [[2]]
##                                                                      Combn Freq
## 91 ms_word-ms_excel-ms_outlk-ms_pub-ms_proj-int_expl-adobe_rd-endnote-spss    1
## 92           ms_word-ms_excel-ms_ppt-ms_acc-int_expl-adobe_rd-endnote-spss    1
## 93                  ms_word-ms_outlk-ms_acc-int_expl-adobe_rd-endnote-spss    1
## 94           ms_word-ms_ppt-ms_outlk-ms_acc-int_expl-adobe_rd-endnote-spss    1
## 95                    ms_word-ms_pub-ms_acc-int_expl-adobe_rd-endnote-spss    1
## 96                  ms_outlk-ms_proj-ms_acc-int_expl-adobe_rd-endnote-spss    1
##    Weighted.Freq Pct.of.Resp Pct.of.Cases
## 91             9       1.633            1
## 92             8       1.452            1
## 93             7       1.270            1
## 94             8       1.452            1
## 95             7       1.270            1
## 96             7       1.270            1
## 
</code></pre>

<h2>References</h2>

<p><code>apply</code> shortcut for creating the <code>Combn</code> column in the output by <a href="http://stackoverflow.com/users/906490/justin">Justin</a><br/><br/>
See: <a href="http://stackoverflow.com/q/11348391/1270695">http://stackoverflow.com/q/11348391/1270695</a> and <a href="http://stackoverflow.com/q/11622660/1270695">http://stackoverflow.com/q/11622660/1270695</a></p>

<p>\newpage</p>

<h1>row.extractor</h1>

<p>The <code>row.extractor</code> function takes a <code>data.frame</code> and extracts rows with the <code>min</code>, <code>median</code>, or <code>max</code> values of a given variable, or extracts rows with specific quantiles of a given variable.</p>

<h2>Arguments</h2>

<ul>
<li><code>data</code>: the source <code>data.frame</code>.</li>
<li><code>extract.by</code>: the column which will be used as the reference for extraction; can be specified either by the column number or the variable name.</li>
<li><code>what</code>: options are <code>min</code> (for all rows matching the minimum value), <code>median</code> (for the median row or rows), <code>max</code> (for all rows matching the maximum value), or <code>all</code> (for <code>min</code>, <code>median</code>, and <code>max</code>); alternatively, a numeric vector can be specified with the desired quantiles, for instance <code>c(0, .25, .5, .75, 1)</code></li>
</ul>

<h2>Examples</h2>

<pre><code class="r"># Load the function!
# require(RCurl)
# baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/row.extractor.R&quot;))))

# Make up some data
set.seed(1)
dat = data.frame(V1 = 1:50, V2 = rnorm(50), 
                 V3 = round(abs(rnorm(50)), digits=2), 
                 V4 = sample(1:30, 50, replace=TRUE))
# Get a sumary of the data
summary(dat)
</code></pre>

<pre><code>##        V1             V2               V3              V4       
##  Min.   : 1.0   Min.   :-2.215   Min.   :0.000   Min.   : 2.00  
##  1st Qu.:13.2   1st Qu.:-0.372   1st Qu.:0.347   1st Qu.: 8.25  
##  Median :25.5   Median : 0.129   Median :0.590   Median :13.00  
##  Mean   :25.5   Mean   : 0.100   Mean   :0.774   Mean   :14.80  
##  3rd Qu.:37.8   3rd Qu.: 0.728   3rd Qu.:1.175   3rd Qu.:20.75  
##  Max.   :50.0   Max.   : 1.595   Max.   :2.400   Max.   :29.00  
</code></pre>

<pre><code class="r"># Get the rows corresponding to the &#39;min&#39;, &#39;median&#39;, and &#39;max&#39; of &#39;V4&#39;
row.extractor(dat, 4) 
</code></pre>

<pre><code>##    V1      V2   V3 V4
## 28 28 -1.4708 0.00  2
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
## 11 11  1.5118 2.40 29
## 14 14 -2.2147 0.03 29
## 18 18  0.9438 1.47 29
## 19 19  0.8212 0.15 29
## 50 50  0.8811 0.47 29
</code></pre>

<pre><code class="r"># Get the &#39;min&#39; rows only, referenced by the variable name
row.extractor(dat, &quot;V4&quot;, &quot;min&quot;) 
</code></pre>

<pre><code>##    V1     V2 V3 V4
## 28 28 -1.471  0  2
</code></pre>

<pre><code class="r"># Get the &#39;median&#39; rows only. Notice that there are two rows 
#    since we have an even number of cases and true median 
#    is the mean of the two central sorted values
row.extractor(dat, &quot;V4&quot;, &quot;median&quot;) 
</code></pre>

<pre><code>##    V1      V2   V3 V4
## 47 47  0.3646 1.28 13
## 29 29 -0.4782 0.07 13
</code></pre>

<pre><code class="r"># Get the rows corresponding to the deciles of &#39;V3&#39;
row.extractor(dat, &quot;V3&quot;, seq(0.1, 1, 0.1)) 
</code></pre>

<pre><code>##    V1       V2   V3 V4
## 10 10 -0.30539 0.14 22
## 26 26 -0.05613 0.29 16
## 39 39  1.10003 0.37 13
## 41 41 -0.16452 0.54 10
## 30 30  0.41794 0.59 26
## 44 44  0.55666 0.70  5
## 37 37 -0.39429 1.06 21
## 49 49 -0.11235 1.22 14
## 34 34 -0.05381 1.52 19
## 11 11  1.51178 2.40 29
</code></pre>

<h2>To Do</h2>

<ul>
<li>Add some error checking to make sure a valid <code>what</code> is provided.</li>
</ul>

<h2>References</h2>

<p><code>which.quantile</code> function by <a href="http://stackoverflow.com/users/755257/cbeleites">cbeleites</a><br/><br/>
See: <a href="http://stackoverflow.com/q/10256503/1270695">http://stackoverflow.com/q/10256503/1270695</a></p>

<p>\newpage</p>

<h1>sample.size</h1>

<p>The <code>sample.size</code> function either calculates the optimum survey sample size when provided with a population size, or the confidence interval of using a certain sample size with a given population. It can be used to generate tables (<code>data.frame</code>s) of different combinations of inputs of the following arguments, which can be useful for showing the effect of each of these in sample size calculation.</p>

<h2>The Arguments</h2>

<ul>
<li><code>population</code>: The population size for which a sample size needs to be calculated.</li>
<li><code>samp.size</code>: The sample size. 

<ul>
<li>This argument is only used when calculating the confidence interval, and defaults to <code>NULL</code>.</li>
</ul></li>
<li><code>c.lev</code>: The desired confidence level. Defaults to a reasonable 95%.</li>
<li><code>c.int</code>: The confidence interval.

<ul>
<li>This argument is only used when calculating the sample size.</li>
<li>If not specified when calculating the sample size, defaults to 5% and a message is provided indicating this; this is also the default action if <code>c.int = NULL</code>.</li>
</ul></li>
<li><code>what</code>: Should the function calculate the desired sample size or the confidence interval?

<ul>
<li>Accepted values are <code>&quot;sample&quot;</code> and <code>&quot;confidence&quot;</code> (quoted), and defaults to &ldquo;<code>sample</code>&rdquo;.</li>
</ul></li>
<li><code>distribution</code>: Response distribution. Defaults to 50%, which will give you the largest sample size. </li>
</ul>

<h2>Examples</h2>

<pre><code class="r"># Load the function!
# require(RCurl)
# baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/sample.size.R&quot;))))
# What should our sample size be for a population of 300?
# All defaults accepted.
sample.size(population = 300)
</code></pre>

<pre><code>## NOTE! Confidence interval set to 5.  To override, set c.int to desired value.
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         95        5           50         169
</code></pre>

<pre><code class="r"># What sample should we take for a population of 300
#   at a confidence level of 97%?
sample.size(population = 300, c.lev = 97)
</code></pre>

<pre><code>## NOTE! Confidence interval set to 5.  To override, set c.int to desired value.
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         97        5           50         183
</code></pre>

<pre><code class="r"># What about if we change our confidence interval?
sample.size(population = 300, c.int = 2.5, what = &quot;sample&quot;)
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         95      2.5           50         251
</code></pre>

<pre><code class="r"># What about if we want to determine the confidence interval
#   of a sample of 140 from a population of 300? A confidence
#   level of 95% is assumed.
sample.size(population = 300, samp.size = 140, what = &quot;confidence&quot;)
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         95     6.06           50         140
</code></pre>

<h2>Advanced Usage</h2>

<p>As the function is vectorized, it is possible to easily make tables with multiple scenarios.</p>

<pre><code class="r"># What should the sample be for populations of 300 to 500 by 50?
sample.size(population=c(300, 350, 400, 450, 500))
</code></pre>

<pre><code>## NOTE! Confidence interval set to 5.  To override, set c.int to desired value.
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         95        5           50         169
## 2        350         95        5           50         183
## 3        400         95        5           50         196
## 4        450         95        5           50         207
## 5        500         95        5           50         217
</code></pre>

<pre><code class="r"># How does varying confidence levels or confidence intervals
#   affect the sample size?
sample.size(population=300, 
            c.lev=rep(c(95, 96, 97, 98, 99), times = 3),
            c.int=rep(c(2.5, 5, 10), each=5))
</code></pre>

<pre><code>##    population conf.level conf.int distribution sample.size
## 1         300         95      2.5           50         251
## 2         300         96      2.5           50         255
## 3         300         97      2.5           50         259
## 4         300         98      2.5           50         264
## 5         300         99      2.5           50         270
## 6         300         95      5.0           50         169
## 7         300         96      5.0           50         176
## 8         300         97      5.0           50         183
## 9         300         98      5.0           50         193
## 10        300         99      5.0           50         207
## 11        300         95     10.0           50          73
## 12        300         96     10.0           50          78
## 13        300         97     10.0           50          85
## 14        300         98     10.0           50          93
## 15        300         99     10.0           50         107
</code></pre>

<pre><code class="r"># What is are the confidence intervals for a sample of
#   150, 160, and 170 from a population of 300?
sample.size(population=300, 
            samp.size = c(150, 160, 170), 
            what=&quot;confidence&quot;)
</code></pre>

<pre><code>##   population conf.level conf.int distribution sample.size
## 1        300         95     5.67           50         150
## 2        300         95     5.30           50         160
## 3        300         95     4.96           50         170
</code></pre>

<p>Note that the use of <code>rep()</code> is required in constructing the arguments for the advanced usage examples where more than one argument takes on multiple values.</p>

<h2>References</h2>

<p>See the <em>2657 Productions News</em> site for how this function progressively developed<sup>[<a href="http://news.mrdwab.com/2010/09/10/a-sample-size-calculator-function-for-r/">http://news.mrdwab.com/2010/09/10/a-sample-size-calculator-function-for-r/</a>].</sup> The <code>sample.size</code> function is based on the following formulas<sup>[See:</sup> Creative Research Systems. (n.d.). <em>Sample size formulas for our sample size calculator</em>. Retrieved from: <a href="http://www.surveysystem.com/sample-size-formula.htm">http://www.surveysystem.com/sample-size-formula.htm</a>. Archived on 07 August 2012 at <a href="http://www.webcitation.org/69kNjMuKe">http://www.webcitation.org/69kNjMuKe</a>.]:</p>

<p>\[ 
\large 
\begin{array}{rcl}
ss &=& \frac{-Z^2\times p\times(1-p)}{c^2} \\ \\
pss &=& \frac{ss}{1+\frac{ss-1}{pop}}
\end{array}
 \]</p>

<p>\newpage</p>

<p>\part{The Functions}</p>

<h1>Where to Get the Functions</h1>

<p>The most current source code for the functions described in this document follow.</p>

<p>To load the functions, you can directly source them from the 2657 R Functions page at github: <a href="https://github.com/mrdwab/2657-R-Functions">https://github.com/mrdwab/2657-R-Functions</a></p>

<p>You should be able to load the functions using the following (replace <code>-----------</code> with the function name<sup>[The</sup> &ldquo;snippets&rdquo; in Part III of this document can all be loaded from the script <code>snippets.R</code>.]):</p>

<pre><code class="r">require(RCurl)
baseURL = c(&quot;https://raw.github.com/mrdwab/2657-R-Functions/master/&quot;)
source(textConnection(getURL(paste0(baseURL, &quot;scripts/-----------.R&quot;))))
</code></pre>

<p>\newpage</p>

<h1>concat.split</h1>

<pre><code class="r">concat.split = function(data, split.col, to.list=FALSE, mode=NULL, 
                        sep=&quot;,&quot;, drop.col=FALSE) {
  # Takes a column with multiple values, splits the values into 
  #   separate columns, and returns a new data.frame.
  # &#39;data&#39; is the source data.frame; &#39;split.col&#39; is the variable that 
  #   needs to be split; &#39;to.list&#39; is whether the split output should
  #   be added as a single variable list (defaults to &quot;FALSE&quot;); 
  #   mode&#39; can be either &#39;binary&#39; or &#39;value&#39; (where &#39;binary&#39; is 
  #   default and it recodes values to 1 or NA); &#39;sep&#39; is the 
  #   character separating each value (defaults to &#39;,&#39;); 
  #   and &#39;drop.col&#39; is logical (whether to remove the original 
  #   variable from the output or not.
  #
  # === EXAMPLES ===
  #
  #       dat = data.frame(V1 = c(&quot;1, 2, 4&quot;, &quot;3, 4, 5&quot;, 
  #                               &quot;1, 2, 5&quot;, &quot;4&quot;, &quot;1, 2, 3, 5&quot;),
  #                        V2 = c(&quot;1;2;3;4&quot;, &quot;1&quot;, &quot;2;5&quot;, 
  #                               &quot;3;2&quot;, &quot;2;3;4&quot;))
  #       dat2 = data.frame(V1 = c(&quot;Fred, John, Sue&quot;, &quot;Jerry, Jill&quot;, 
  #                                &quot;Sally, Ryan&quot;, &quot;Susan, Amos, Ben&quot;))
  #
  #       concat.split(dat, 1) 
  #       concat.split(dat, 2, sep=&quot;;&quot;)
  #       concat.split(dat, &quot;V2&quot;, sep=&quot;;&quot;, mode=&quot;value&quot;)
  #       concat.split(dat, &quot;V1&quot;, mode=&quot;binary&quot;)
  #       concat.split(dat2, 1)
  #       concat.split(dat2, &quot;V1&quot;, drop.col=TRUE)
  #
  # See: http://stackoverflow.com/q/10100887/1270695

  if (is.numeric(split.col)) split.col = split.col
  else split.col = which(colnames(data) %in% split.col)

  a = as.character(data[ , split.col])
  b = strsplit(a, sep)

  if (isTRUE(to.list)) {
    varname = paste(names(data[split.col]), &quot;_list&quot;, sep=&quot;&quot;)
    if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
      data[varname] = list(lapply(lapply(b, as.character),
                                  function(x) gsub(&quot;^\\s+|\\s+$&quot;, 
                                                   &quot;&quot;, x)))
    } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
      data[varname] = list(lapply(b, as.numeric))
    } 
    if (isTRUE(drop.col)) data[-split.col]
    else data
  } else if (!isTRUE(to.list)) {
    if (suppressWarnings(is.na(try(max(as.numeric(unlist(b))))))) {
      what = &quot;string&quot;
      ncol = max(unlist(lapply(b, function(i) length(i))))
    } else if (!is.na(try(max(as.numeric(unlist(b)))))) {
      what = &quot;numeric&quot;
      ncol = max(as.numeric(unlist(b)))
    }

    m = matrix(nrow = nrow(data), ncol = ncol)
    v = vector(&quot;list&quot;, nrow(data))

    if (identical(what, &quot;string&quot;)) {
      temp = as.data.frame(t(sapply(b, &#39;[&#39;, 1:ncol)))
      names(temp) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep=&quot;&quot;)
      temp = apply(temp, 2, function(x) gsub(&quot;^\\s+|\\s+$&quot;, &quot;&quot;, x))
      temp1 = cbind(data, temp)
    } else if (identical(what, &quot;numeric&quot;)) {
      for (i in 1:nrow(data)) {
        v[[i]] = as.numeric(strsplit(a, sep)[[i]])
      }

      temp = v

      for (i in 1:nrow(data)) {
        m[i, temp[[i]]] = temp[[i]]
      }

      m = data.frame(m)
      names(m) = paste(names(data[split.col]), &quot;_&quot;, 1:ncol, sep=&quot;&quot;)

      if (is.null(mode) || identical(mode, &quot;binary&quot;)) {
        temp1 = cbind(data, replace(m, m != &quot;NA&quot;, 1))
      } else if (identical(mode, &quot;value&quot;)) {
        temp1 = cbind(data, m)
      }
    } 

    if (isTRUE(drop.col)) temp1[-split.col]
    else temp1    
  }  
}
</code></pre>

<p>\newpage</p>

<h1>df.sorter</h1>

<pre><code class="r">df.sorter = function(data, var.order=names(data), col.sort=NULL, at.start=TRUE ) {
  # Sorts a data.frame by columns or rows or both.
  # Can also subset the data columns by using &#39;var.order&#39;.
  # Can refer to variables either by names or number.
  # If referring to variable by number, and sorting both the order
  #   of variables and the sorting within variables, refer to the
  #   variable numbers of the final data.frame.
  #
  # === EXAMPLES ===
  #
  #    library(foreign)
  #    temp = &quot;http://www.ats.ucla.edu/stat/stata/modules/kidshtwt.dta&quot;
  #    kidshtwt = read.dta(temp); rm(temp)
  #    df.sorter(kidshtwt, var.order = c(&quot;fam&quot;, &quot;bir&quot;, &quot;wt&quot;, &quot;ht&quot;))
  #    df.sorter(kidshtwt, var.order = c(&quot;fam&quot;, &quot;bir&quot;, &quot;wt&quot;, &quot;ht&quot;),
  #              col.sort = c(&quot;birth&quot;, &quot;famid&quot;)) # USE FULL NAMES HERE
  #    df.sorter(kidshtwt, var.order = c(1:4),   # DROP THE WT COLUMNS
  #              col.sort = 3)                   # SORT BY HT1  

  if (is.numeric(var.order)) 
    var.order = colnames(data)[var.order]
  else var.order = var.order

  a = names(data)
  b = length(var.order)
  subs = vector(&quot;list&quot;, b)

  if (isTRUE(at.start)) {
    for (i in 1:b) {
      subs[[i]] = sort(grep(paste(&quot;^&quot;, var.order[i],
                                  sep=&quot;&quot;, collapse=&quot;&quot;),
                            a, value=TRUE))
    }  
  } else if (!isTRUE(at.start)) {
    for (i in 1:b) {
      subs[[i]] = sort(grep(var.order[i], a, value=TRUE))
    }
  }

  x = unlist(subs)
  y = data[ , x ]

  if (is.null(col.sort)) {
    y
  } else if (is.numeric(col.sort)) {
    col.sort = colnames(y)[col.sort]
    y[do.call(order, y[col.sort]), ]
  } else if (!is.numeric(col.sort)) {
    col.sort = col.sort
    y[do.call(order, y[col.sort]), ]
  }
}
</code></pre>

<p>\newpage</p>

<h1>multi.freq.table</h1>

<pre><code class="r">multi.freq.table = function(data, sep=&quot;&quot;, boolean=TRUE, 
                            factors=NULL, 
                            NAto0=TRUE, basic=FALSE, 
                            dropzero=TRUE, clean=TRUE) {
  # Takes multiple-response data and tabulates it according
  #   to the possible combinations of each variable.
  #
  # === EXAMPLES ===
  #
  #     set.seed(1)
  #     dat = data.frame(A = sample(c(0, 1), 20, replace=TRUE), 
  #                      B = sample(c(0, 1), 20, replace=TRUE), 
  #                      C = sample(c(0, 1), 20, replace=TRUE),
  #                      D = sample(c(0, 1), 20, replace=TRUE),
  #                      E = sample(c(0, 1), 20, replace=TRUE))
  #   multi.freq.table(dat)
  #   multi.freq.table(dat[1:3], sep=&quot;-&quot;, dropzero=TRUE)
  #
  # See: http://stackoverflow.com/q/11348391/1270695
  #      http://stackoverflow.com/q/11622660/1270695

  if (!is.data.frame(data)) {
    stop(&quot;Input must be a data frame.&quot;)
  }

  if (isTRUE(boolean)) {
    CASES = nrow(data)
    RESPS = sum(data, na.rm=TRUE)

    if(isTRUE(NAto0)) {
      data[is.na(data)] = 0
      VALID = CASES
      VRESP = RESPS
    } else if(!isTRUE(NAto0)) {
      data = data[complete.cases(data), ]
      VALID = CASES - (CASES - nrow(data))
      VRESP = sum(data)
    }

    if(isTRUE(basic)) {
      counts = data.frame(Freq = colSums(data),
                          Pct.of.Resp = (colSums(data)/sum(data))*100,
                          Pct.of.Cases = (colSums(data)/nrow(data))*100)
    } else if (!isTRUE(basic)) {
      counts = data.frame(table(data))
      Z = counts[, c(intersect(names(data), names(counts)))]
      Z = rowSums(sapply(Z, as.numeric)-1)
      if(Z[1] == 0) { Z[1] = 1 }
      N = ncol(counts)
      counts$Combn = apply(counts[-N] == 1, 1, 
                           function(x) paste(names(counts[-N])[x],
                                             collapse=sep))
      counts$Weighted.Freq = Z*counts$Freq
      counts$Pct.of.Resp = (counts$Weighted.Freq/sum(data))*100
      counts$Pct.of.Cases = (counts$Freq/nrow(data))*100
      if (isTRUE(dropzero)) {
        counts = counts[counts$Freq != 0, ]
      } else if (!isTRUE(dropzero)) {
        counts = counts
      }
      if (isTRUE(clean)) {
        counts = data.frame(Combn = counts$Combn, Freq = counts$Freq, 
                            Weighted.Freq = counts$Weighted.Freq,
                            Pct.of.Resp = counts$Pct.of.Resp, 
                            Pct.of.Cases = counts$Pct.of.Cases)
      }
    }
    message(&quot;Total cases:     &quot;, CASES, &quot;\n&quot;,
            &quot;Valid cases:     &quot;, VALID, &quot;\n&quot;,
            &quot;Total responses: &quot;, RESPS, &quot;\n&quot;,
            &quot;Valid responses: &quot;, VRESP, &quot;\n&quot;)
    counts
  } else if (!isTRUE(boolean)) {
    CASES = nrow(data)
    RESPS = length(data[!is.na(data)])
    if (!isTRUE(any(sapply(data, is.factor)))) {
      if (is.null(factors)) {
        stop(&quot;Input variables must be factors.
        Please provide factors using the &#39;factors&#39; argument or
             convert your data to factor before using function.&quot;)
      } else {
        data[sapply(data, is.character)] = 
          lapply(data[sapply(data, is.character)], 
                 function(x) factor(x, levels=factors))
      }      
    }
    if (isTRUE(basic)) {
      ROWS = levels(unlist(data))
      OUT = table(unlist(data))
      PCT = (OUT/sum(OUT)) * 100
      OUT = data.frame(ROWS, OUT, PCT, row.names=NULL)
      OUT = data.frame(Item = OUT[, 1], Freq = OUT[, 3], 
                       Pct.of.Resp = OUT[, 5],
                       Pct.of.Cases = (OUT[, 3]/CASES)*100)
      message(&quot;Total cases:     &quot;, CASES, &quot;\n&quot;,
              &quot;Total responses: &quot;, RESPS, &quot;\n&quot;)
      OUT
    } else if (!isTRUE(basic)) {
      Combos = apply(data, 1, function(x) paste0(sort(x), collapse = sep))
      Weight = as.numeric(rowSums(!is.na(data)))
      OUT = data.frame(table(Combos, Weight))
      OUT = OUT[OUT$Freq &gt; 0, ]
      OUT$Weight = as.numeric(as.character(OUT$Weight))
      if(OUT$Weight[1] == 0) { OUT$Weight[1] = 1 }
      OUT$Weighted.Freq = OUT$Weight*OUT$Freq
      OUT$Pct.of.Resp = (OUT$Weighted.Freq/RESPS)*100
      OUT$Pct.of.Cases = (OUT[, 3]/CASES)*100
      message(&quot;Total cases:     &quot;, CASES, &quot;\n&quot;,
              &quot;Total responses: &quot;, RESPS, &quot;\n&quot;)
      OUT[-2]
    } 
  }
}
</code></pre>

<p>\newpage</p>

<h1>row.extractor</h1>

<pre><code class="r">row.extractor = function(data, extract.by, what=&quot;all&quot;) {
  # Extracts rows with min, median, and max values, or by quantiles.
  # Values for &quot;what&quot; can be &quot;min&quot;, &quot;median&quot;, &quot;max&quot;, &quot;all&quot;, or a
  #   vector specifying the desired quantiles.
  # Values for &quot;extract.by&quot; can be the variable name or number.
  #
  # === EXAMPLES ===
  #
  #    set.seed(1)
  #    dat = data.frame(V1 = 1:10, V2 = rnorm(10), V3 = rnorm(10), 
  #                     V4 = sample(1:20, 10, replace=T))
  #    dat2 = dat[-10,]
  #    row.extractor(dat, 4, &quot;all&quot;)
  #    row.extractor(dat1, 4, &quot;min&quot;)
  #    row.extractor(dat, &quot;V4&quot;, &quot;median&quot;)
  #    row.extractor(dat, 4, c(0, .5, 1))
  #    row.extractor(dat, &quot;V4&quot;, c(0, .25, .5, .75, 1))
  #
  # &quot;which.quantile&quot; function by cbeleites:
  # http://stackoverflow.com/users/755257/cbeleites
  # See: http://stackoverflow.com/q/10256503/1270695

  if (is.numeric(extract.by)) {
    extract.by = extract.by
  } else if (is.numeric(extract.by) != 0) {
    extract.by = which(colnames(data) %in% &quot;extract.by&quot;)
  } 

  if (is.character(what)) {
    which.median = function(data, extract.by) {
      a = data[, extract.by]
      if (length(a) %% 2 != 0) {
        which(a == median(a))
      } else if (length(a) %% 2 == 0) {
        b = sort(a)[c(length(a)/2, length(a)/2+1)]
        c(max(which(a == b[1])), min(which(a == b[2])))
      }
    }

    X1 = data[which(data[extract.by] == min(data[extract.by])), ] # min
    X2 = data[which(data[extract.by] == max(data[extract.by])), ] # max
    X3 = data[which.median(data, extract.by), ]                # median

    if (identical(what, &quot;min&quot;)) {
      X1
    } else if (identical(what, &quot;max&quot;)) {
      X2
    } else if (identical(what, &quot;median&quot;)) {
      X3
    } else if (identical(what, &quot;all&quot;)) {
      rbind(X1, X3, X2)
    }
  } else if (is.numeric(what)) {
    which.quantile &lt;- function (data, extract.by, what, na.rm = FALSE) {

      x = data[ , extract.by]

      if (! na.rm &amp; any (is.na (x)))
        return (rep (NA_integer_, length (what)))

      o &lt;- order (x)
      n &lt;- sum (! is.na (x))
      o &lt;- o [seq_len (n)]

      nppm &lt;- n * what - 0.5
      j &lt;- floor(nppm)
      h &lt;- ifelse((nppm == j) &amp; ((j%%2L) == 0L), 0, 1)
      j &lt;- j + h

      j [j == 0] &lt;- 1
      o[j]
    }
    data[which.quantile(data, extract.by, what), ]           # quantile
  }
}
</code></pre>

<p>\newpage</p>

<h1>sample.size</h1>

<pre><code class="r">sample.size = function(population, samp.size=NULL, c.lev=95, 
                       c.int=NULL, what = &quot;sample&quot;, 
                       distribution=50) {
  # Returns a data.frame of sample sizes or confidence
  #   intervals for different conditions provided by 
  #   the following arguments.
  #
  # populaton: Population size
  # samp.size: Sample size
  # c.lev: Confidence level
  # c.int: Confidence interval (+/-)
  # what: Whether sample size or confidence interval
  #       is being calculated.
  # distribution: Response distribution
  # 
  # === EXAMPLES ===
  #
  #   sample.size(300)
  #   sample.size(300, 150, what=&quot;confidence&quot;)
  #   sample.size(c(300, 400, 500), c.lev=97)

  z = qnorm(.5+c.lev/200)

  if (identical(what, &quot;sample&quot;)) {
    if (is.null(c.int)) {
      c.int = 5

      message(&quot;NOTE! Confidence interval set to 5.
      To override, set c.int to desired value.\n&quot;)

    } else if (!is.null(c.int) == 1) {
      c.int = c.int
    }

    if (!is.null(samp.size)) {
      message(&quot;NOTE! &#39;samp.size&#39; value provided but ignored.
      See output for actual sample size(s).\n&quot;)
    }

    ss = (z^2 * (distribution/100) * 
      (1-(distribution/100)))/((c.int/100)^2)
    samp.size = ss/(1 + ((ss-1)/population))    

  } else if (identical(what, &quot;confidence&quot;)) {
    if (is.null(samp.size)) {
      stop(&quot;Missing &#39;samp.size&#39; with no default value.&quot;)
    }
    if (!is.null(c.int)) {
      message(&quot;NOTE! &#39;c.int&#39; value provided but ignored.
      See output for actual confidence interval value(s).\n&quot;)
    }

    ss = ((population*samp.size-samp.size)/(population-samp.size))
    c.int = round(sqrt((z^2 * (distribution/100) * 
      (1-(distribution/100)))/ss)*100, digits = 2)

  } else if (what %in% c(&quot;sample&quot;, &quot;confidence&quot;) == 0) {
    stop(&quot;&#39;what&#39; must be either &#39;sample&#39; or &#39;confidence&#39;&quot;)
  }

  RES = data.frame(population = population,
                   conf.level = c.lev,
                   conf.int = c.int,
                   distribution = distribution,
                   sample.size = round(samp.size, digits = 0))
  RES
}
</code></pre>

<p>\newpage</p>

<p>\part{Snippets and Tips}</p>

<h1>Snippets</h1>

<h2>Load All Scripts and Data Files From Multiple Directories</h2>

<pre><code class="r">load.scripts.and.data = function(path,
                                 pattern=list(scripts = &quot;*.R$&quot;,
                                              data = &quot;*.rda$|*.Rdata$&quot;), 
                                 ignore.case=TRUE) {
  # Reads all the data files and scripts from specified directories.
  #     In general, should only need to specify the directories.
  #     Specify directories without trailing slashes.
  #
  # === EXAMPLE ===
  #
  #    load.scripts.and.data(c(&quot;~/Dropbox/Public&quot;, 
  #                            &quot;~/Dropbox/Public/R Functions&quot;))

  file.sources = list.files(path, pattern=pattern$scripts, 
                            full.names=TRUE, ignore.case=ignore.case)
  data.sources = list.files(path, pattern=pattern$data,
                            full.names=TRUE, ignore.case=ignore.case)
  sapply(data.sources,load,.GlobalEnv)
  sapply(file.sources,source,.GlobalEnv)
}
</code></pre>

<h2>Convert a List of Data Frames Into Individual Data Frames</h2>

<pre><code class="r">unlist.dfs = function(data) {
  # Specify the quoted name of the source list.
  q = get(data)
  prefix = paste0(data, &quot;_&quot;, 1:length(q))
  for (i in 1:length(q)) assign(prefix[i], q[[i]], envir=.GlobalEnv)
}
</code></pre>

<h3>Example</h3>

<p><em>Note that the list name must be quoted.</em></p>

<pre><code class="r"># Sample data
temp = list(A = data.frame(A = 1:2, B = 3:4), 
            B = data.frame(C = 5:6, D = 7:8))
temp
</code></pre>

<pre><code>## $A
##   A B
## 1 1 3
## 2 2 4
## 
## $B
##   C D
## 1 5 7
## 2 6 8
## 
</code></pre>

<pre><code class="r"># Remove any files with similar names to output
rm(list=ls(pattern=&quot;temp_&quot;))
# The following should not work
temp_1
</code></pre>

<pre><code>## Error: object &#39;temp_1&#39; not found
</code></pre>

<pre><code class="r"># Split it up!
unlist.dfs(&quot;temp&quot;)
# List files with the desired pattern
ls(pattern=&quot;temp_&quot;)
</code></pre>

<pre><code>## [1] &quot;temp_1&quot; &quot;temp_2&quot;
</code></pre>

<pre><code class="r"># View the new files
temp_1
</code></pre>

<pre><code>##   A B
## 1 1 3
## 2 2 4
</code></pre>

<pre><code class="r">temp_2
</code></pre>

<pre><code>##   C D
## 1 5 7
## 2 6 8
</code></pre>

<h2>Convert a Data Frame Into a List With Each Column Becoming a List Item</h2>

<pre><code class="r">dfcols.list = function(data, vectorize=FALSE) {
  # Specify the unquoted name of the data.frame to convert
  if (isTRUE(vectorize)) {
    dat.list = sapply(1:ncol(data), function(x) data[x])
  } else if (!isTRUE(vectorize)) {
    dat.list = lapply(names(data), function(x) data[x])
  }
  dat.list
}
</code></pre>

<h3>Examples</h3>

<pre><code class="r"># Sample data
dat = data.frame(A = c(1:2), B = c(3:4), C = c(5:6))
dat
</code></pre>

<pre><code>##   A B C
## 1 1 3 5
## 2 2 4 6
</code></pre>

<pre><code class="r"># Split into a list, retaining data.frame structure
dfcols.list(dat)
</code></pre>

<pre><code>## [[1]]
##   A
## 1 1
## 2 2
## 
## [[2]]
##   B
## 1 3
## 2 4
## 
## [[3]]
##   C
## 1 5
## 2 6
## 
</code></pre>

<pre><code class="r"># Split into a list, converting to vector
dfcols.list(dat, vectorize=TRUE)
</code></pre>

<pre><code>## $A
## [1] 1 2
## 
## $B
## [1] 3 4
## 
## $C
## [1] 5 6
## 
</code></pre>

<h2>Rename an Object in the Workplace</h2>

<pre><code class="r">mv &lt;- function (a, b) {
  # Source: https://stat.ethz.ch/pipermail/r-help/2008-March/156035.html
  anm &lt;- deparse(substitute(a))
  bnm &lt;- deparse(substitute(b))
  if (!exists(anm,where=1,inherits=FALSE))
    stop(paste(anm, &quot;does not exist.\n&quot;))
  if (exists(bnm,where=1,inherits=FALSE)) {
    ans &lt;- readline(paste(&quot;Overwrite &quot;, bnm, &quot;? (y/n) &quot;, sep =  &quot;&quot;))
    if (ans != &quot;y&quot;)
      return(invisible())
  }
  assign(bnm, a, pos = 1)
  rm(list = anm, pos = 1)
  invisible()
}
</code></pre>

<h3>Basic Usage</h3>

<p>If there is already an object with the same name in the workplace, the function will ask you if you want to replace the object or not. Otherwise, the basic usage is:</p>

<pre><code class="r"># Rename &quot;object_1&quot; to &quot;object_2&quot;
mv(object_1, object_2)
</code></pre>

<p>\newpage</p>

<h1>Tips</h1>

<p>Many of the following tips are useful for reducing repetitious tasks. They might seem silly or unnecessary with the small examples provided, but they can be <em>huge</em> time-savers when dealing with larger objects or larger sets of data.</p>

<h2>Batch Convert Factor Variables to Character Variables</h2>

<p>In the example data below, <code>author</code> and <code>title</code> are automatically converted to factor (unless you add the argument <code>stringsAsFactor = FALSE</code> when you are creating the data). What if you forgot and actually needed the variables to be in mode <code>as.character</code> instead?</p>

<p>Use <code>sapply</code> to identify which variables are currently factors and convert them to <code>as.character</code>.</p>

<pre><code class="r">dat = data.frame(title = c(&quot;title1&quot;, &quot;title2&quot;, &quot;title3&quot;),
                 author = c(&quot;author1&quot;, &quot;author2&quot;, &quot;author3&quot;),
                 customerID = c(1, 2, 1))
str(dat)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    3 obs. of  3 variables:
##  $ title     : Factor w/ 3 levels &quot;title1&quot;,&quot;title2&quot;,..: 1 2 3
##  $ author    : Factor w/ 3 levels &quot;author1&quot;,&quot;author2&quot;,..: 1 2 3
##  $ customerID: num  1 2 1
</code></pre>

<pre><code class="r"># Left of the equal sign identifies and extracts the factor variables;
#    right converts them from factor to character
dat[sapply(dat, is.factor)] = lapply(dat[sapply(dat, is.factor)], 
                                     as.character)
str(dat)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    3 obs. of  3 variables:
##  $ title     : chr  &quot;title1&quot; &quot;title2&quot; &quot;title3&quot;
##  $ author    : chr  &quot;author1&quot; &quot;author2&quot; &quot;author3&quot;
##  $ customerID: num  1 2 1
</code></pre>

<h2>Using Reduce to Merge Multiple Data Frames at Once</h2>

<p>The <code>merge</code> function in R only merges two objects at a time. This is usually fine, but what if you had several <code>data.frames</code> that needed to be merged?</p>

<p>Consider the following data, where we want to take monthly tables and merge them into an annual table:</p>

<pre><code class="r">set.seed(1)
JAN = data.frame(ID = sample(5, 3), JAN = sample(LETTERS, 3))
FEB = data.frame(ID = sample(5, 3), FEB = sample(LETTERS, 3))
MAR = data.frame(ID = sample(5, 3), MAR = sample(LETTERS, 3))
APR = data.frame(ID = sample(5, 3), APR = sample(LETTERS, 3))
</code></pre>

<p>If we wanted to merge these into a single <code>data.frame</code> using <code>merge</code>, we might end up creating several temporary objects and merging those, like this:</p>

<pre><code class="r">temp_1 = merge(JAN, FEB, all=TRUE)
temp_2 = merge(temp_1, MAR, all=TRUE)
temp_3 = merge(temp_2, APR, all=TRUE)
</code></pre>

<p>Or, we might nest a whole bunch of <code>merge</code> commands together, something like this:</p>

<pre><code class="r">merge(merge(merge(JAN, FEB, all=TRUE), 
            MAR, all=TRUE), 
      APR, all=TRUE)
</code></pre>

<p>However, that first option requires a lot of unnecessary typing and produces unnecessary objects that we then need to remember to remove, and the second option is not very reader-friendly&mdash;try doing a merge like that with, say, 12 <code>data.frames</code> if we had an entire year of data!</p>

<p>Use <code>Reduce</code> instead, simply specifying all the objects to be merged in a <code>list</code>:</p>

<pre><code class="r">Reduce(function(x, y) merge(x, y, all=TRUE), 
       list(JAN, FEB, MAR, APR))
</code></pre>

<pre><code>##   ID  JAN  FEB  MAR  APR
## 1  2    X    E    R    F
## 2  3 &lt;NA&gt;    F    X    D
## 3  4    V &lt;NA&gt;    M    Q
## 4  5    F    B &lt;NA&gt; &lt;NA&gt;
</code></pre>

<h3>How Much Memory Are the Objects in Your Workspace Using?</h3>

<p>Sometimes you need to just check and see how much memory the objects in your workspace occupy.</p>

<pre><code class="r">sort(sapply(ls(), function(x) {object.size(get(x))}))
</code></pre>

</body>

</html>

